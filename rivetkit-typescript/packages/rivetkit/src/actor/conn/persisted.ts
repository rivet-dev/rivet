/**
 * Persisted data structures for connections.
 *
 * Keep this file in sync with the Connection section of rivetkit-typescript/packages/rivetkit/schemas/actor-persist/
 */

import * as cbor from "cbor-x";
import type * as persistSchema from "@/schemas/actor-persist/mod";
import { bufferToArrayBuffer } from "@/utils";

export type RequestId = ArrayBuffer;

export type Cbor = ArrayBuffer;

// MARK: Connection
/** Event subscription for connection */
export interface PersistedSubscription {
	eventName: string;
}

/** Connection associated with hibernatable WebSocket that should persist across lifecycles */
export interface PersistedConn<CP, CS> {
	/** Connection ID generated by RivetKit */
	id: string;
	parameters: CP;
	state: CS;
	subscriptions: PersistedSubscription[];
	/** Request ID of the hibernatable WebSocket */
	hibernatableRequestId: RequestId;
	/** Last seen message index for this WebSocket */
	msgIndex: number;
	requestPath: string;
	requestHeaders: Record<string, string>;
}

/**
 * Converts persisted connection data to BARE schema format for serialization.
 * @throws {Error} If the connection is ephemeral (not hibernatable)
 */
export function convertConnToBarePersistedConn<CP, CS>(
	persist: PersistedConn<CP, CS>,
): persistSchema.Conn {
	return {
		id: persist.id,
		parameters: bufferToArrayBuffer(cbor.encode(persist.parameters)),
		state: bufferToArrayBuffer(cbor.encode(persist.state)),
		subscriptions: persist.subscriptions.map((sub) => ({
			eventName: sub.eventName,
		})),
		hibernatableRequestId: persist.hibernatableRequestId,
		msgIndex: BigInt(persist.msgIndex),
		requestPath: persist.requestPath,
		requestHeaders: new Map(Object.entries(persist.requestHeaders)),
	};
}

/**
 * Converts BARE schema format to persisted connection data.
 * @throws {Error} If the connection is ephemeral (not hibernatable)
 */
export function convertConnFromBarePersistedConn<CP, CS>(
	bareData: persistSchema.Conn,
): PersistedConn<CP, CS> {
	return {
		id: bareData.id,
		parameters: cbor.decode(new Uint8Array(bareData.parameters)),
		state: cbor.decode(new Uint8Array(bareData.state)),
		subscriptions: bareData.subscriptions.map((sub) => ({
			eventName: sub.eventName,
		})),
		hibernatableRequestId: bareData.hibernatableRequestId,
		msgIndex: Number(bareData.msgIndex),
		requestPath: bareData.requestPath,
		requestHeaders: Object.fromEntries(bareData.requestHeaders),
	};
}
