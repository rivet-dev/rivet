---
title: "Multiplayer Game"
description: "Pragmatic patterns for building multiplayer games with RivetKit: matchmaking, tick loops, realtime state, interest management, and validation."
templates: []
---

Game-focused patterns for building multiplayer games with RivetKit, intended as a practical checklist you can adapt per genre.

This document uses the base reference game types from `examples/multiplayer-game-patterns/src/actors/*` in alphabetical order.

| Game Classification | Common Examples |
| --- | --- |
| `battle-royale` | Fortnite, Apex Legends, PUBG, Warzone |
| `competitive` | Counter-Strike competitive, VALORANT ranked, Rocket League playlists |
| `io-style` | Agar.io, Slither.io, surviv.io |
| `open-world` | Minecraft survival servers, Rust-like worlds, MMO zone/chunk worlds |
| `party` | Fall Guys private lobbies, custom game rooms, social party sessions |
| `ranked` | Chess ladders, competitive card games, duel arena ranked queues |
| `turn-based` | Chess correspondence, Words With Friends, async board games |

## Architecture Patterns

- Rivet Actor per gameplay boundary (room, chunk, match), not per physics entity.
  - In realtime simulations, keep players, projectiles, and objects in actor state. Do not create one actor per player/object/physics body.

- Coordinator and data actors: use a coordinator (matchmaker/world index) to create/find data actors (rooms/chunks/matches). See [Coordinator & Data Actors](/docs/actors/design-patterns#coordinator--data-actors).
- Lifecycle: data actors can call `c.destroy()` when empty to keep state clean.
- Communication path: prefer direct actor actions/events for game flows, and avoid adding extra internal HTTP hops unless you need an external integration boundary.

## Matchmaking Patterns

| Game Classification | Matchmaking Pattern | Actor Keys Recommendation | Behavior In Example |
| --- | --- | --- | --- |
| `battle-royale` | Single global queue, oldest-first fill into large lobbies. | Matchmaker: `battleRoyaleMatchmaker["main"]`<br/>Match: `battleRoyaleMatch[matchId]` | Creates a match once queue reaches minimum players, then fills up to cap. |
| `competitive` | Mode-based fixed-capacity queues (`duo`, `squad`) with team assignment. | Matchmaker: `competitiveMatchmaker["main"]`<br/>Match: `competitiveMatch[matchId]` | Builds only full matches per mode and pre-assigns team IDs. |
| `io-style` | Open-lobby routing to the fullest room below capacity. | Matchmaker: `ioStyleMatchmaker["main"]`<br/>Match: `ioStyleMatch[matchId]` | Reuses active rooms, heartbeats room counts, and auto-creates when needed. |
| `open-world` | Coordinator-based chunk routing from world coordinates. | Index: `openWorldIndex["main"]`<br/>Chunk: `openWorldChunk[worldId,chunkX,chunkY]` | Resolves world positions into chunk keys and preloads nearby chunk windows. |
| `party` | Host-created private party with explicit party-code joins. | Matchmaker: `partyMatchmaker["main"]`<br/>Match: `partyMatch[matchId]` | Uses party code discovery and host-gated phase transitions. |
| `ranked` | ELO-based queue with widening search window over wait time. | Matchmaker: `rankedMatchmaker["main"]`<br/>Match: `rankedMatch[matchId]` | Pairs two players, starts at narrow ELO delta, then expands window by wait time. |
| `turn-based` | Async invite flow plus open-pool pairing. | Matchmaker: `asyncTurnBasedMatchmaker["main"]`<br/>Match: `asyncTurnBasedMatch[matchId]` | Supports direct invites and pooled matching for long-lived asynchronous play. |

## Actor Ownership Constraints (Current Examples)

These examples enforce ownership mostly with coordinator-created assignments and per-player join tokens. They are scaffold constraints, not full identity auth.

| Constraint Area | Current Constraint In Examples | Implication |
| --- | --- | --- |
| Lobby/match creation authority | Coordinator actors create gameplay actors (`*Matchmaker`, `openWorldIndex`) via `create(...)`/`getOrCreate(...)`. Clients are expected to call the coordinator, not create match/chunk actors directly. | Lifecycle and discovery stay centralized in one actor per pattern. |
| Player record creation authority | Gameplay actors create in-memory player rows on `join` after token checks (`joinToken`, party auth, room auth). | Player state inside a lobby/match/chunk is server-created at join time. |
| Match/chunk trust boundary | Coordinator actors own assignment/index rows, and gameplay actors reject unknown players during `onBeforeConnect` via per-player tokens. | Orphaned sessions and unauthorized joins are rejected at connect time. |
| Action ownership after join | Connection state (`c.conn.state.playerId`) is used to gate mutating actions (`not_joined`, `host_only`, `player_mismatch`, turn ownership checks). | A joined connection can only act for its bound player role in that actor. |
| Open-world chunk ownership | Chunk keys are canonical (`openWorldChunk[worldId,chunkX,chunkY]`), `ensureChunk` enforces key/world/chunk consistency, and cross-chunk moves return the next chunk key instead of silently migrating state. | World partition boundaries are explicit and server-checked. |
| Explicit gap: identity source of truth | Many coordinator actions still accept raw `playerId` input from clients (for example queue/join discovery paths) without binding identity to `c.conn.id` or an authenticated principal. | Good for examples, but production code should map connection/auth identity to player ID server-side. |

## Game Loop And Tick Rates

### Recommended Tick Rates

| Game Classification | Tick Rate In Example | Interval | Notes |
| --- | --- | --- | --- |
| `battle-royale` | 10 ticks/sec | `100ms` | Uses a fixed loop for zone progression and match lifecycle checks. |
| `competitive` | 20 ticks/sec | `50ms` | Uses a tighter loop for live team action snapshots. |
| `io-style` | 10 ticks/sec | `100ms` | Uses lightweight periodic room snapshots for drop-in sessions. |
| `open-world` | 10 ticks/sec per chunk actor | `100ms` | Each chunk actor runs independently so load scales by active chunks. |
| `party` | No continuous tick | N/A | Event-driven lobby flow (`join`, `start`, `finish`) without realtime simulation. |
| `ranked` | 20 ticks/sec | `50ms` | Uses fixed ticks while live for deterministic pacing and broadcast cadence. |
| `turn-based` | No continuous tick | N/A | Turn submission drives updates; no realtime loop required. |

### Implementing Tick Loops

| Pattern | Use When | Implementation Guidance |
| --- | --- | --- |
| Fixed realtime loop | `battle-royale`, `competitive`, `io-style`, `open-world`, `ranked` | Run in `run` with `sleep(tickMs)` and exit on `c.aborted`. |
| Action-driven updates | `party`, `turn-based` | Mutate and broadcast only on actions/events rather than scheduled ticks. |
| Coarse offline progression | Any mode with idle progression | Use `c.schedule.after(...)` with coarse windows (for example 5 to 15 minutes) and apply catch-up from elapsed wall clock time. |

## Realtime Data Model

- Publish authoritative state from the server as events, using snapshots and/or diffs.
  - Example pattern: send a full snapshot on join/resync, then send per-tick diffs for regular updates.
- Keep events small and typed. For high-frequency updates, batch per tick.
- Avoid using UI-framework state/hooks for high-frequency game updates. Keep simulation and render loops in engine code, and use framework state for basic UI only (menus, HUD, forms), especially with Canvas or Three.js renderers.
- When all players should receive the same update, use `c.broadcast(...)`. When players should receive different/private data, send per-connection payloads with `conn.send(...)`.
- Frontend bundling: place shared types, constants, and pure helpers in `src/shared/` (for example `src/shared/sim/*`). Avoid importing backend actor modules into browser bundles, since backend modules often include Node-only dependencies (`fs`, SQLite bindings, etc).

## Interest Management

### Sharded Worlds

- Partition very large worlds across data actors (for example chunk actors keyed by `worldId:chunkX:chunkY`).
- Clients subscribe only to nearby partitions (for example a 3x3 chunk window around the player).
- Use this when you are confident the world is large and state-heavy (for example sandbox builders or MMOs), not as a default for small matches.

### Generic Interest Management

- Send each client only the state relevant to that player (for example by proximity, line-of-sight, team, or game phase).
- For shooters and action games, limit replication by proximity and optional field-of-view checks.
- Keep filtering server-side so clients never receive data they should not see.

## Netcode

| Model | When To Use | How To Implement (Basic) |
| --- | --- | --- |
| Client-authoritative movement | Low-stakes realtime games where responsiveness is prioritized (for example social spaces and simple `.io` loops). | Client sends movement updates at a capped rate. Server validates max speed/delta/bounds, rejects invalid moves, rate limits spam, and periodically resyncs canonical state. |
| Server-authoritative from inputs | Competitive or high-integrity games where fairness and cheat resistance are critical. | Client sends input commands with sequence/timestamp. Server simulates on fixed ticks, resolves rules/collision, publishes authoritative snapshots, and client reconciles local prediction. |
| Client interpolation and smoothing | Any realtime game streaming remote entities under jittery networks. | Buffer snapshots per entity and render slightly in the past. Interpolate most frames, extrapolate briefly when missing updates, and snap when error exceeds threshold. |

| Game Classification | Recommended Model | Client Has Authority Over | Server Has Authority Over |
| --- | --- | --- | --- |
| `battle-royale` | Server-authoritative from inputs | Local prediction, camera, interpolation of remote players | Match phase, eliminations, zone state, hit/collision resolution, final winner |
| `competitive` | Server-authoritative from inputs | Local prediction and presentation smoothing | Team assignment, action validity, phase transitions, scoring/win conditions |
| `io-style` | Hybrid (client movement + server validation) | Frequent movement intents and cosmetic responsiveness | Bounds/speed checks, room membership, canonical shared snapshot |
| `open-world` | Hybrid by subsystem | Client-side camera and immediate local feel; optional local prediction | Chunk ownership/routing, persistence, cross-player visibility, anti-cheat validation, canonical world state |
| `party` | Server-authoritative lobby control | UI state and local readiness signals | Membership list, host permissions, start/finish transitions |
| `ranked` | Server-authoritative from inputs | Local responsiveness and interpolation only | Input validation, authoritative tick state, match result, rating updates |
| `turn-based` | Server-authoritative turns | Drafting a move before submit | Turn ownership, committed move log, turn order, completion state |

## Shared Simulation Logic

Use this for logic shared between client and server while keeping the server authoritative.

- Keep shared logic basic and pure (movement integration, input transforms, constants).
- Put shared code in `src/shared/`, and keep deterministic simulation helpers in `src/shared/sim/*` with no side effects.
- Do not share actor runtime code (DB access, network calls, `c.*` context, timers).
- The server remains authoritative. Client-side shared logic is for prediction/smoothing and should reconcile to server state.

## Physics And Spatial Indexing

| Game Classification | Physics Intensity | Recommended Physics Strategy | Spatial Indexing Guidance |
| --- | --- | --- | --- |
| `battle-royale` | High | Server-authoritative simulation. Use `@dimforge/rapier3d` for shooter-style 3D worlds, or `@dimforge/rapier2d` for top-down 2D variants. | Keep broad queries for loot/nearby entities with `rbush`/`flatbush`; use `d3-quadtree` for proximity lookups. |
| `competitive` | Medium to high | Prefer server-owned collision/rules with deterministic tick updates. Use Rapier when contacts or rigid-body complexity grows. | Use spatial indexing for broadphase and per-team/per-zone visibility filters. |
| `io-style` | Low to medium | Start with kinematic movement and server validation. Add heavy engine simulation only if gameplay demands it. | Add `rbush` or `d3-quadtree` once room entity count is no longer trivially small. |
| `open-world` | Medium to high at scale | Use chunk-local server simulation and escalate to Rapier when per-chunk contacts become complex. | Keep chunk-level broadphase indexes and load only nearby chunk windows per player. |
| `party` | Low | Usually no dedicated physics in lobby phase. If mini-games are added, keep simple kinematic server checks first. | Usually minimal indexing needs unless party mode adds realtime world interactions. |
| `ranked` | Medium to high | Use server-authoritative collision and resolution. Favor deterministic simulation and strict validation before visual polish. | Apply indexing for hit checks and visibility filtering to reduce per-tick costs. |
| `turn-based` | Very low | No continuous realtime physics; treat moves as discrete state transitions with rules validation. | Indexing is optional and usually only needed for board/query convenience at large scale. |

| Dimension | Primary Engine | Fallback Engines | Notes |
| --- | --- | --- | --- |
| 2D | `@dimforge/rapier2d` | `planck-js`, `matter-js` | Prefer custom kinematic logic first for simple games, then escalate when contacts become complex. |
| 3D | `@dimforge/rapier3d` | `cannon-es`, `ammo.js` | For multiplayer shooters, prefer full dynamic server simulation over collision-only query logic. |

| Spatial Indexing Default | Recommendation |
| --- | --- |
| Broadphase | Do not use naive `O(n^2)` checks once entity counts can grow. |
| AABB index | Use `rbush` for dynamic sets or `flatbush` for static-ish sets. Insert circles/capsules as AABBs. |
| Point index | Use `d3-quadtree` for nearest-neighbor and within-radius queries. |

| Escalate To Rapier When | Why |
| --- | --- |
| You need joints, stacked bodies, or stable contact manifolds | These need robust rigid-body/contact solvers. |
| You have many dynamic bodies or high collision density | Purpose-built broadphase and solvers hold up better than custom kinematic logic. |
| You need complex shapes (rotated boxes/polygons in 2D, capsules/convex hulls/triangle meshes in 3D) | Hand-rolled collision code becomes costly and error-prone. |

| Cross-Cutting Rule | Recommendation |
| --- | --- |
| Engine + indexing | Physics engines and spatial indexing are complementary. Use indexing for interest management and broad queries even with an engine. |
| Engine exclusivity | Physics engines are mutually exclusive in practice for one simulation. Pick one engine per simulation. |
| Backend/runtime boundary | Keep frontend-only libs out of backend simulation paths; treat server state as authoritative. |
| Client mesh raycasts | `three-mesh-bvh` is optional and mostly for client-side fast raycasts on dense static meshes. |

## Security And Anti-Cheat

Start with this baseline, then harden further for competitive or high-risk environments.

### Baseline Checklist

Apply this checklist to all implementations.

- Identity:
  - Use `c.conn.id` as the authoritative identity of the caller.
  - Never accept `playerId` (or similar) from the client as the source of truth.
- Authorization:
  - Validate that the caller is allowed to mutate the target entity (room membership, turn ownership, host-only actions).
- Input validation:
  - Clamp sizes/lengths and validate enums.
  - Validate usernames (length, allowed chars, avoid unbounded Unicode).
- Rate limiting:
  - Per-connection rate limits for spammy actions (chat, join/leave, fire, movement updates).
- State integrity:
  - Server recomputes derived state (scores, win conditions, placements).
  - Avoid client-authoritative changes to inventory/currency/leaderboard totals.

### Movement Validation

Use this specifically for client-authoritative movement flows.

Clients may send position/rotation updates for smoothness, but the server must:

- Enforce max delta per update (speed cap) based on elapsed time.
- Reject or clamp teleports.
- Enforce world bounds (and basic collision if applicable).
- Rate limit update frequency (for example 20Hz max).

## Persistence

Use this section to decide when SQLite is a better fit than in-memory actor state.

- Rivet Actor state is fine for small ephemeral state (rooms, short-lived matches).
- Prefer SQLite (`rivetkit/db`) when state is:
  - Large or table-like (tiles/blocks/buildings/inventory).
  - Needs queries/indexes beyond key lookups.
  - Expected to persist long-term and grow over time.
- Matchmakers/coordinators may also use SQLite when their indexing state can grow large (room registries, matchmaking pools, large queues).
- When using `rivetkit/db`, assume multiple actions can hit the same actor DB concurrently. Keep DB operations serialized (either by library-provided mutexing or your own).

## NPCs / AI

- Assert `OPENAI_API_KEY` is present on backend startup.
- Limit tokens and rate limit per player.
- Keep NPC memory minimal and bounded (short summaries), or skip long-term memory if the game does not need it.
