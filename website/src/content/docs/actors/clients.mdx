# Clients

Clients are used to get and communicate with actors from your application. Clients can be created from either your frontend or backend.

## Creating a Client

<Tabs>
	<Tab title="Frontend Client">
		For frontend applications or external services:

		<CodeGroup>
		```typescript {{"title":"JavaScript"}}
		import { createClient } from "rivetkit/client";
		import type { registry } from "./registry";  // Must use `type`

		const client = createClient<typeof registry>();
		```

		```tsx {{"title":"React"}}
		import { createRivetKit } from "@rivetkit/react";
		import type { registry } from "./registry";  // Must use `type`

		const { useActor } = createRivetKit<typeof registry>();
		```
		</CodeGroup>

		<Accordion title="Advanced Options">
			Clients include the following options:

			```typescript
			const client = createClient<typeof registry>({
				endpoint: "https://api.rivet.dev",
				namespace: "default",
				token: "my-token",
				encoding: "json",  // "json", "cbor", or "bare"
				headers: { "X-Custom-Header": "value" }
			});
			```
		</Accordion>
	</Tab>

	<Tab title="Backend Client">
		From your backend server that hosts the registry:

		```typescript
		import { registry } from "./registry";

		const { client } = registry.start();
		```
	</Tab>

	<Tab title="Actor-to-Actor">
		From within an actor to communicate with other actors:

		```typescript
		const myActor = actor({
			actions: {
				callOtherActor: (c) => {
					const client = c.client<typeof registry>();
					// ...
				}
			}
		});
		```

		Read more about [communicating between actors](/docs/actors/communicating-between-actors).
	</Tab>
</Tabs>

## Getting an Actor

### `getOrCreate`

Returns a handle to an existing actor or creates one if it doesn't exist:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const counter = client.counter.getOrCreate("my-counter");
const count = await counter.increment(5);
```

```tsx {{"title":"React"}}
const counter = useActor({
  name: "counter",
  key: ["my-counter"],
});

// Call actions through the connection
await counter.connection?.increment(5);
```
</CodeGroup>

Pass initialization data when creating:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const game = client.game.getOrCreate("game-123", {
  createWithInput: { gameMode: "tournament", maxPlayers: 8 }
});
```

```tsx {{"title":"React"}}
const game = useActor({
  name: "game",
  key: ["game-123"],
  createWithInput: { gameMode: "tournament", maxPlayers: 8 },
});
```
</CodeGroup>

### `get`

Returns a handle to an existing actor or `null` if it doesn't exist:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const handle = client.myActor.get("actor-id");

if (handle) {
  await handle.someAction();
}
```

```tsx {{"title":"React"}}
import { createClient } from "rivetkit/client";
import { useMemo } from "react";
import type { registry } from "./registry";

// `get` is not currently supported with useActor.
// Use createClient with useMemo instead:

function MyComponent() {
  const client = useMemo(() => createClient<typeof registry>(), []);
  const handle = useMemo(() => client.myActor.get("actor-id"), [client]);

  // Use handle to call actions
}
```
</CodeGroup>

### `create`

Creates a new actor, failing if one already exists with that key:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const newGame = await client.game.create("game-456", {
  input: { gameMode: "classic" }
});
```

```tsx {{"title":"React"}}
import { createClient } from "rivetkit/client";
import { useMemo, useEffect, useState } from "react";
import type { registry } from "./registry";

// `create` is not currently supported with useActor.
// Use createClient with useMemo instead:

function MyComponent() {
  const client = useMemo(() => createClient<typeof registry>(), []);
  const [handle, setHandle] = useState(null);

  useEffect(() => {
    client.game.create("game-456", {
      input: { gameMode: "classic" }
    }).then(setHandle);
  }, [client]);

  // Use handle to call actions
}
```
</CodeGroup>

### `getForId`

Connect to an actor using its internal ID:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const actor = client.myActor.getForId("lrysjam017rhxofttna2x5nzjml610");
```

```tsx {{"title":"React"}}
import { createClient } from "rivetkit/client";
import { useMemo } from "react";
import type { registry } from "./registry";

// `getForId` is not currently supported with useActor.
// Use createClient with useMemo instead:

function MyComponent({ actorId }: { actorId: string }) {
  const client = useMemo(() => createClient<typeof registry>(), []);
  const handle = useMemo(() => client.myActor.getForId(actorId), [client, actorId]);

  // Use handle to call actions
}
```
</CodeGroup>

Prefer using keys over internal IDs for simplicity.

## Calling Actions

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const counter = client.counter.getOrCreate("my-counter");

const count = await counter.increment(5);
const value = await counter.getCount();
await counter.reset();
```

```tsx {{"title":"React"}}
const counter = useActor({
  name: "counter",
  key: ["my-counter"],
});

// Call actions through the connection
const count = await counter.connection?.increment(5);
const value = await counter.connection?.getCount();
await counter.connection?.reset();
```
</CodeGroup>

In JavaScript, actions called without `connect()` are stateless. Each call is independent without a persistent connection. In React, `useActor` automatically manages a persistent connection.

## Connecting to an Actor

For real-time use cases, establish a persistent connection to the actor:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const counter = client.counter.getOrCreate("live-counter");
const conn = counter.connect();

// Listen for events
conn.on("countChanged", (newCount: number) => {
  console.log("Count updated:", newCount);
});

// Call actions through the connection
await conn.increment(1);
```

```tsx {{"title":"React"}}
const [count, setCount] = useState(0);

const counter = useActor({
  name: "counter",
  key: ["live-counter"],
});

// Listen for events
counter.useEvent("countChanged", (newCount: number) => {
  setCount(newCount);
});

// Call actions through the connection
await counter.connection?.increment(1);
```
</CodeGroup>

## Subscribing to Events

Listen for events from connected actors:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const conn = client.chatRoom.getOrCreate("general").connect();

// Listen for events
conn.on("messageReceived", (message) => {
  console.log(`${message.from}: ${message.text}`);
});

// Listen once
conn.once("gameStarted", () => {
  console.log("Game has started!");
});
```

```tsx {{"title":"React"}}
const [messages, setMessages] = useState<Message[]>([]);

const chatRoom = useActor({
  name: "chatRoom",
  key: ["general"],
});

// Listen for events (automatically cleaned up on unmount)
chatRoom.useEvent("messageReceived", (message) => {
  setMessages((prev) => [...prev, message]);
});
```
</CodeGroup>

## Full-Stack Type Safety

Import types from your registry for end-to-end type safety:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
import { createClient } from "rivetkit/client";
import type { registry } from "./registry";

const client = createClient<typeof registry>();

// IDE autocomplete shows available actors and actions
const counter = client.counter.getOrCreate("my-counter");
const count = await counter.increment(5);
```

```tsx {{"title":"React"}}
import { createRivetKit } from "@rivetkit/react";
import type { registry } from "./registry";

const { useActor } = createRivetKit<typeof registry>();

// IDE autocomplete shows available actors and actions
const counter = useActor({ name: "counter", key: ["my-counter"] });
const count = await counter.connection?.increment(5);
```
</CodeGroup>

<Warning>
Use `import type` to avoid accidentally bundling backend code in your frontend.
</Warning>

## Advanced

### Disposing Clients & Connections

Dispose clients to close all connections:

```typescript
await client.dispose();
```

Dispose individual connections when finished:

```typescript
const conn = actor.connect();

try {
  conn.on("event", handler);
  await conn.action();
} finally {
  await conn.dispose();
}
```

<Note>
When using `useActor` in React, connections are automatically disposed when the component unmounts. No manual cleanup is required.
</Note>

### Connection Parameters

Pass custom data to the actor when connecting:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const chat = client.chatRoom.getOrCreate("general", {
  params: {
    userId: "user-123",
    displayName: "Alice"
  }
});
```

```tsx {{"title":"React"}}
const chat = useActor({
  name: "chatRoom",
  key: ["general"],
  params: {
    userId: "user-123",
    displayName: "Alice"
  },
});
```
</CodeGroup>

### Authentication

Pass authentication tokens when connecting:

<CodeGroup>
```typescript {{"title":"JavaScript"}}
const chat = client.chatRoom.getOrCreate("general", {
  params: {
    authToken: "jwt-token-here"
  }
});
```

```tsx {{"title":"React"}}
const chat = useActor({
  name: "chatRoom",
  key: ["general"],
  params: {
    authToken: "jwt-token-here"
  },
});
```
</CodeGroup>

See [authentication](/docs/actors/authentication) for more details.

### Error Handling

<CodeGroup>
```typescript {{"title":"JavaScript (Connection)"}}
import { ActorError } from "rivetkit/client";

const conn = actor.connect();
conn.onError((error: ActorError) => {
  if (error.code === "forbidden") {
    window.location.href = "/login";
  }
});
```

```typescript {{"title":"JavaScript (Stateless)"}}
import { ActorError } from "rivetkit/client";

try {
  const result = await actor.protectedAction();
} catch (error) {
  if (error instanceof ActorError && error.code === "forbidden") {
    window.location.href = "/login";
  }
}
```

```tsx {{"title":"React"}}
import { ActorError } from "rivetkit/client";

const actor = useActor({ name: "myActor", key: ["id"] });

const handleAction = async () => {
  try {
    await actor.connection?.protectedAction();
  } catch (error) {
    if (error instanceof ActorError && error.code === "forbidden") {
      window.location.href = "/login";
    }
  }
};
```
</CodeGroup>

See [errors](/docs/actors/errors) for more details.

### Actor Resolution

`get` and `getOrCreate` return immediately without making a network request. The actor is resolved lazily when you call an action or `connect()`.

To explicitly resolve an actor and get its ID, use `resolve()`:

```typescript
const handle = client.counter.getOrCreate("my-counter");
const actorId = await handle.resolve();
console.log(actorId); // "lrysjam017rhxofttna2x5nzjml610"
```

## API Reference

- [`createClient`](/typedoc/functions/rivetkit.client_mod.createClient.html) - Function to create clients
- [`Client`](/typedoc/types/rivetkit.mod.Client.html) - Client type
- [`ActorHandle`](/typedoc/types/rivetkit.client_mod.ActorHandle.html) - Handle for interacting with actors
- [`ActorConn`](/typedoc/types/rivetkit.client_mod.ActorConn.html) - Connection to actors
- [`ClientRaw`](/typedoc/interfaces/rivetkit.client_mod.ClientRaw.html) - Raw client interface

