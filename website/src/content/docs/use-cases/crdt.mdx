# Realtime Docs

## Challenges of Building Realtime Collaborative Documents

Common tools: Yjs, Automerge, operational transforms, WebSocket servers, Redis for pub/sub, database for persistence

Main pain points:
- Coordinating realtime updates across multiple users requires complex pub/sub infrastructure
- Persisting document state and CRDT data structures to databases adds latency
- Managing conflict resolution and synchronization logic is complex
- Scaling WebSocket connections and state management across servers
- Handling offline users and reconnection scenarios

## How Rivet Solves This

Rivet provides actors that maintain CRDT document state in memory and broadcast updates in realtime without external infrastructure.

**In-Memory CRDTs**: Store Yjs or Automerge documents directly in actor state for ultra-fast reads and writes with zero database latency.

```typescript
import * as Y from "yjs";

const collaborativeDoc = actor({
  state: {
    ydoc: new Uint8Array(), // Yjs document state
    connectedUsers: [] as string[]
  },

  actions: {
    applyUpdate: (c, update: Uint8Array, userId: string) => {
      // Apply Yjs update to document
      const doc = new Y.Doc();
      Y.applyUpdate(doc, c.state.ydoc);
      Y.applyUpdate(doc, update);

      c.state.ydoc = Y.encodeStateAsUpdate(doc);

      // Broadcast to all connected users
      c.broadcast("docUpdate", { update, userId });
    }
  }
});
```

**Built-in Realtime**: WebSocket connections are built into actors, eliminating the need for separate pub/sub systems. See [events](/docs/actors/events).

**Automatic Persistence**: Document state persists automatically without database round trips. Learn about [state management](/docs/actors/state).

**Multi-User Support**: Track connected users and their cursor positions using [connection state](/docs/actors/connections).

## Full Example Projects

<CardGroup>
<Card href="https://github.com/rivet-dev/rivet/tree/main/examples/crdt" title="Collaborative CRDT Docs" />
</CardGroup>
