---
title: "Swift"
description: "Connect Swift apps to Rivet Actors."
skill: true
---

## Install

Add the Swift package dependency and import `RivetKitClient`:

```swift
// Package.swift
dependencies: [
    .package(url: "https://github.com/rivet-dev/rivetkit-swift", from: "2.0.41")
]

targets: [
    .target(
        name: "MyApp",
        dependencies: [
            .product(name: "RivetKitClient", package: "rivetkit-swift")
        ]
    )
]
```

## Minimal Client

<Tabs>
<Tab title="Endpoint URL">

```swift
import RivetKitClient

let config = try ClientConfig(
    endpoint: "https://my-namespace:pk_...@api.rivet.dev"
)
let client = RivetKitClient(config: config)

let handle = client.getOrCreate("counter", ["my-counter"])
let count: Int = try await handle.action("increment", arg: 1, as: Int.self)
```

</Tab>
<Tab title="Explicit Fields">

```swift
import RivetKitClient

let config = try ClientConfig(
    endpoint: "https://api.rivet.dev",
    namespace: "my-namespace",
    token: "pk_..."
)
let client = RivetKitClient(config: config)

let handle = client.getOrCreate("counter", ["my-counter"])
let count: Int = try await handle.action("increment", arg: 1, as: Int.self)
```

</Tab>
</Tabs>

## Environment Configuration

`ClientConfig()` (and `RivetKitClient()`'s convenience initializer) automatically read:

- `RIVET_ENGINE` or `RIVET_ENDPOINT` (endpoint)
- `RIVET_NAMESPACE`
- `RIVET_TOKEN`
- `RIVET_RUNNER`

If none are set, the default endpoint is `http://127.0.0.1:6420`.

## Endpoint Format

Endpoints support URL auth syntax:

```
https://namespace:token@api.rivet.dev
```

You can also pass the endpoint without auth and provide `RIVET_NAMESPACE` and `RIVET_TOKEN` separately. For serverless deployments, set the endpoint to your appâ€™s `/api/rivet` URL. See [Endpoints](/docs/general/endpoints#url-auth-syntax) for details.

## Stateless vs Stateful

```swift
let handle = client.getOrCreate("counter", ["my-counter"])

// Stateless: each call is independent
let current: Int = try await handle.action("getCount", as: Int.self)

// Stateful: keep a connection open for realtime events
let conn = handle.connect()
let unsubscribe = await conn.on("count") { args in
    print(args)
}
_ = try await conn.action("increment", arg: 1, as: Int.self)
await unsubscribe()
```

## Getting Actors

```swift
struct GameInput: Encodable {
    let mode: String
}

let room = client.getOrCreate("chatRoom", ["room-42"])
let existing = client.get("chatRoom", ["room-42"])
let created = try await client.create(
    "game",
    ["game-1"],
    options: CreateOptions(input: GameInput(mode: "ranked"))
)
let byId = client.getForId("chatRoom", "actor-id")
let resolvedId = try await room.resolve()
```

## Keys

Keys uniquely identify actor instances. Use compound keys (arrays) for hierarchical addressing:

```swift
let room = client.getOrCreate("chatRoom", ["org-acme", "general"])
```

Don't build keys with string interpolation like `"org:\(userId)"` when `userId` contains user data. Use arrays instead to prevent key injection attacks.

## Connection Parameters

```swift
struct ConnParams: Encodable {
    let authToken: String
}

let chat = client.getOrCreate(
    "chatRoom",
    ["general"],
    options: GetOrCreateOptions(params: ConnParams(authToken: "jwt-token-here"))
)

let conn = chat.connect()
```

## Subscribing to Events

```swift
let conn = client.getOrCreate("chatRoom", ["general"]).connect()
let unsubscribe = await conn.on("message") { args in
    print(args)
}
let unsubscribeOnce = await conn.once("gameOver") { _ in
    print("done")
}
await unsubscribe()
await unsubscribeOnce()
```

## Connection Lifecycle

```swift
let conn = client.getOrCreate("chatRoom", ["general"]).connect()

let onOpen = await conn.onOpen { print("connected") }
let onClose = await conn.onClose { print("disconnected") }
let onError = await conn.onError { error in
    print(error.code)
}
let onStatus = await conn.onStatusChange { status in
    print(status)
}

await onOpen()
await onClose()
await onError()
await onStatus()
await conn.dispose()
```

## Low-Level HTTP & WebSocket

For actors that implement `onRequest` or `onWebSocket`, you can call them directly:

```swift
let handle = client.getOrCreate("chatRoom", ["general"])

let response = try await handle.fetch("history")
let history: [String] = try response.json([String].self)

let websocket = try await handle.websocket(path: "stream")
try await websocket.send(text: "hello")
let message = try await websocket.receive()
```

## Calling from Backend

Use the same client in server-side Swift (Vapor, Hummingbird, etc.):

```swift
let handle = client.getOrCreate("counter", ["server-counter"])
let count: Int = try await handle.action("increment", arg: 1, as: Int.self)
```

## Error Handling

```swift
do {
    _ = try await client.getOrCreate("user", ["user-123"])
        .action("updateUsername", arg: "ab", as: String.self)
} catch let error as ActorError {
    print(error.code)
    print(error.metadata ?? [:])
}
```

## API Reference

- `RivetKitClient` - Create a client
- `RivetKitClient(endpoint:)` - Create a client with an explicit endpoint
- `ClientConfig` - Configure endpoint, namespace, and token
- `ActorHandle` - Stateless action calls
- `ActorConnection` - Stateful connection and events
- `ActorError` - Typed actor errors
