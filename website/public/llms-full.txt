# Rivet Documentation - Complete

This file contains the complete documentation for Rivet, an open-source alternative to Durable Objects.

## Actions

# Actions

Actions are how your backend, frontend, or other actors can communicate with actors. Actions are defined as functions in the actor configuration and can be called from clients.

Actions are very lightweight. They can be called thousands of times per second safely.

Actions are executed via HTTP requests or via WebSockets if [using `.connect()`](/docs/actors/connections).

For advanced use cases that require direct access to HTTP requests or WebSocket connections, see [raw HTTP and WebSocket handling](/docs/actors/fetch-and-websocket-handler).

## Writing Actions

Actions are defined in the `actions` object when creating an actor:

```typescript
const mathUtils = actor(,
  actions: 
  }
});
```

Each action receives a context object (commonly named `c`) as its first parameter, which provides access to state, connections, and other utilities. Additional parameters follow after that.

## Calling Actions

Actions can be called in different ways depending on your use case:

```typescript }
const client = createClient("http://localhost:8080");
const counter = await client.counter.getOrCreate();
const result = await counter.increment(42);
console.log(result); // The value returned by the action
```

Learn more about [communicating with actors from the frontend](/docs/actors/communicating-between-actors).

```typescript }
const registry = setup(
});

const  = registry.start();

const app = new Hono();

// Use the client to call actions on a request
app.get("/foo", () => );

serve(app);
```

Learn more about [communicating with actors from the backend](/docs/actors/communicating-between-actors).

```typescript }
const actorA = actor(,
  actions: 
  }
});
```

Learn more about [communicating between actors](/docs/actors/communicating-between-actors).

Calling actions from the client are async and require an `await`, even if the action itself is not async.

### Type Safety

The actor client includes type safety out of the box. When you use `createClient()`, TypeScript automatically infers action parameter and return types:

```typescript }
// Create simple counter
const counter = actor(,
  actions: 
  }
});

// Create and the app
const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Type-safe client usage
const counter = await client.counter.get();
await counter.increment(123); // OK
await counter.increment("non-number type"); // TypeScript error
await counter.nonexistentMethod(123); // TypeScript error
```

## Error Handling

Actors provide robust error handling out of the box for actions.

### User Errors

`UserError` can be used to return rich error data to the client. You can provide:

-   A human-readable message
-   A machine-readable code that's useful for matching errors in a try-catch (optional)
-   A metadata object for providing richer error context (optional)

For example:

```typescript }
const user = actor(,
  actions: 
        });
      }
      
      // Rest of the user registration logic...
    }
  }
});
```

```typescript }
try  catch (error) 
}
```

### Internal Errors

All other errors will return an error with the code `internal_error` to the client. This helps keep your application secure, as errors can sometimes expose sensitive information.

## Schema Validation

If passing data to an actor from the frontend, use a library like [Zod](https://zod.dev/) to validate input data.

For example, to validate action parameters:

```typescript }
// Define schema for action parameters
const IncrementSchema = z.object();

const counter = actor(,
  actions:  = IncrementSchema.parse(params);
        c.state.count += count;
        return c.state.count;
      } catch (err) 
        });
      }
    }
  }
});
```

## Authentication

By default, actors' actions are only accessible from your server-side client.

In order to expose actions publicly to the external client, you'll need to define `onAuth`. More documentation on authentication is available [here](/docs/actors/authentication). Read more about the [types of clients](/docs/actors/clients)

## Streaming Return Data

Actions have a single return value. To stream realtime data in response to an action, use [events](/docs/actors/events).

## Using `ActionContext` Externally

When writing complex logic for actions, you may want to extract parts of your implementation into separate helper functions. When doing this, you'll need a way to properly type the context parameter.

Rivet provides the `ActionContextOf` utility type for exactly this purpose:

```typescript
const counter = actor(,
  
  actions: 
  }
});

// Simple helper function with typed context
function incrementCount(c: ActionContextOf) 
```

See [helper types](/docs/actors/helper-types) for more details on using `ActionContextOf` and other utility types.
## Authentication

# Authentication

Secure your actors with authentication and authorization

Rivet provides multiple authentication methods to secure your actors. Use `onAuth` for server-side validation or `onBeforeConnect` for actor-level authentication.

## Authentication Methods

### onAuth Hook (Recommended)

The `onAuth` hook runs on the HTTP server before clients can access actors. This is the preferred method for most authentication scenarios.

```typescript
const chatRoom = actor(, ) => 
    
    // Validate token and return user data
    const user = await validateJWT(token);
    return ;
  },
  
  state: ,
  
  actions:  = c.conn.auth;
      
      if (role !== "member") 
      
      const message = ;
      
      c.state.messages.push(message);
      c.broadcast("newMessage", message);
      return message;
    }
  }
});
```

### `onBeforeConnect` Hook

Use `onBeforeConnect` when you need access to actor state for authentication:

```typescript
const userProfileActor = actor(),
  
  state: ,
  
  onBeforeConnect: async (c, opts) =>  = opts;
    const userId = await validateUser(params.token);
    
    // Check if user can access this profile
    if (c.state.isPrivate && c.state.ownerId !== userId) 
  },
  
  createConnState: (c, opts, params: ) => ;
  },
  
  actions: 
      
      // Update profile...
    }
  }
});
```

Prefer `onAuth` over `onBeforeConnect` when possible, as `onAuth` runs on the HTTP server and uses fewer actor resources.

## Connection Parameters

Pass authentication data when connecting:

```typescript
// Client side
const chat = client.chatRoom.getOrCreate(["general"]);
const connection = chat.connect();

// Or with action calls
const counter = client.counter.getOrCreate(["user-counter"], );
```

## Intent-Based Authentication (Experimental)

The `onAuth` hook receives an `intents` parameter indicating what the client wants to do:

```typescript
const secureActor = actor(, ) =>  else if (intents.has("connect")) 
    
    throw new UserError("Unknown intent");
  },
  
  actions: 
  }
});
```

## Error Handling

### Authentication Errors

Use specific error types for different authentication failures:

```typescript
const protectedActor = actor() => 
    
    try  catch (error) 
      throw new Unauthorized("Invalid authentication token");
    }
  },
  
  actions: 
      return "Admin content";
    }
  }
});
```

### Client Error Handling

Handle authentication errors on the client:

```typescript
try  catch (error)  else if (error.code === "FORBIDDEN") 
}
```

## Integration with Auth Providers

### Better Auth Integration

  Complete integration guide for Better Auth

### JWT Authentication

```typescript
const jwtActor = actor(, ) => 
    
    try ;
    } catch (error) 
  },
  
  actions:  = c.conn.auth;
      
      if (!permissions.includes("write")) 
      
      // Perform action...
      return ;
    }
  }
});
```

### API Key Authentication

```typescript
const apiActor = actor(, ) => 
    
    // Validate with your API service
    const response = await fetch(`$/validate`, 
    });
    
    if (!response.ok) 
    
    const user = await response.json();
    return ;
  },
  
  actions: 
      
      return "Premium content";
    }
  }
});
```

## Role-Based Access Control

Implement RBAC with helper functions:

```typescript
// auth-helpers.ts
function requireRole(requiredRole: string) ;
    
    if (roleHierarchy[userRole]  ' required`);
    }
  };
}

// usage in actor
const forumActor = actor() => ,
  
  actions: ,
    
    editPost: (c, postId: string, content: string) => 
  }
});
```

## Testing Authentication

Mock authentication for testing:

```typescript
// test helpers
function createMockAuth(userData: any) ;
}

// in tests
describe("Protected Actor", () => )
    };
    
    const result = await mockActor.adminOnly();
    expect(result).toBe("Admin content");
  });
  
  it("denies non-admin actions", async () => )
    };
    
    await expect(mockActor.adminOnly()).rejects.toThrow("Admin access required");
  });
});
```

## Best Practices

1. **Use onAuth**: Prefer `onAuth` over `onBeforeConnect` for most authentication
2. **Validate Early**: Authenticate at the HTTP server level when possible
3. **Specific Errors**: Use appropriate error types (Unauthorized, Forbidden)
4. **Rate Limiting**: Consider rate limiting in your authentication logic
5. **Token Refresh**: Handle token expiration gracefully on the client
6. **Audit Logging**: Log authentication events for security monitoring
7. **Least Privilege**: Only grant the minimum permissions needed
## Actor Clients

# Actor Clients

Learn how to call actions and connect to actors from client applications using Rivet's TypeScript client library.

Rivet also supports [React](/docs/clients/react) and [Rust](/docs/clients/rust) clients.

Using the RivetKit client is completely optional. If you prefer to write your own networking logic, you can either:

- Write your own HTTP endpoints and use the client returned from `registry.start` (see below)
- Make HTTP requests directly to the registry (see [OpenAPI spec](/docs/clients/openapi))

## Client Setup

There are several ways to create a client for communicating with actors:

		From your backend server that hosts the registry:

		```typescript }
		const  = registry.start();

		const app = new Hono();

		app.post("/foo", () => );

		serve(app);
		```

		This client doesn't [require authentication](/docs/actors/authentication).

		For frontend applications or external services connecting to your Rivet backend:

		```typescript }
		// IMPORTANT: Must use `type`

		const client = createClient("http://localhost:8080");

		const response = await client.otherActor.getOrCreate().foo();
		```

		Configure the client with additional options:

		```typescript }
		const client = createClient("http://localhost:8080", );
		```

		This client [requires authentication](/docs/actors/authentication).

		**Important**: Use `import type` when importing the registry type in order to
		avoid accidentally bundling your backend code.

		```typescript }
		// ✅ Do this
		// 🚫 Not this
		```

		From within an actor to communicate with other actors:

		```typescript }
		const myActor = actor(
			}
		});
		```

		This client doesn't [require authentication](/docs/actors/authentication).

		Read more about [communicating between actors](/docs/actors/communicating-between-actors).

## `ActorClient`

The `ActorClient` provides methods for finding and creating actors. All methods return an `ActorHandle` that you can use to call actions or establish connections.

### `get(key?, opts?)` - Find Existing Actor

Returns a handle to an existing actor or `null` if it doesn't exist:

```typescript
// Get existing actor by key
const handle = client.myActor.get(["actor-id"]);

if (handle)  else 
```

### `getOrCreate(key?, opts?)` - Find or Create Actor

Returns a handle to an existing actor or creates a new one if it doesn't exist:

```typescript
// Get or create actor (synchronous)
const counter = client.counter.getOrCreate(["my-counter"]);

// With initialization input
const game = client.game.getOrCreate(["game-123"], 
});

// Call actions immediately
const count = await counter.increment(5);
```

`get()` and `getOrCreate()` are synchronous and return immediately. The actor is created lazily when you first call an action.

### `create(key?, opts?)` - Create New Actor

Explicitly creates a new actor instance, failing if one already exists:

```typescript
// Create new actor (async)
const newGame = await client.game.create(["game-456"], 
});

// Actor is guaranteed to be newly created
await newGame.initialize();
```

### `getForId(id, opts?)` - Find by Internal ID

Connect to an actor using its internal system ID:

```typescript
// Connect by internal ID
const actorId = "55425f42-82f8-451f-82c1-6227c83c9372";
const actor = client.myActor.getForId(actorId);

await actor.performAction();
```

Prefer using keys over internal IDs for actor discovery. IDs are primarily for debugging and advanced use cases.

## `ActorHandle`

An `ActorHandle` represents a reference to an actor instance and provides methods for calling actions and establishing connections. You get an `ActorHandle` from the `ActorClient` methods like `get()`, `getOrCreate()`, and `create()`.

### Calling Actions

You can call actions directly on an `ActorHandle`:

```typescript
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions directly
const count = await counter.increment(5);
const currentValue = await counter.getCount();
await counter.reset();
```

Actions called on an `ActorHandle` are stateless - each call is independent and doesn't maintain a persistent connection to the actor.

### `fetch(input, init?)` - Raw HTTP Requests

Make direct HTTP requests to the actor's `onFetch` handler:

```typescript
const actor = client.myActor.getOrCreate(["key"]);

// GET request
const response = await actor.fetch("/api/hello", );
const data = await response.json();

// POST request with body
const postResponse = await actor.fetch("/api/echo", ,
  body: JSON.stringify()
});

// Can also pass a Request object
const request = new Request("/api/data", );
const requestResponse = await actor.fetch(request);
```

See [Fetch & WebSocket Handler](/docs/actors/fetch-and-websocket-handler) documentation for more information.

For most use cases, actions provide a higher-level API that's easier to work with than raw HTTP handlers.

### `websocket(path?, protocols?)` - Raw WebSocket Connections

Create direct WebSocket connections to the actor's `onWebSocket` handler:

```typescript
const actor = client.myActor.getOrCreate(["key"]);

// Basic WebSocket connection
const ws = await actor.websocket();
ws.addEventListener("message", (event) => );
ws.send("Hello WebSocket!");

// WebSocket with custom path
const streamWs = await actor.websocket("/stream");

// WebSocket with protocols
const protocolWs = await actor.websocket("/", ["chat", "v1"]);
```

See [Fetch & WebSocket Handler](/docs/actors/fetch-and-websocket-handler) documentation for more information.

For most use cases, actions & events provide a higher-level API that's easier to work with than raw HTTP handlers.

### `connect(params?)` - Establish Stateful Connection

To open a stateful connection using `ActorConn`, call `.connect()`:

```typescript
const counter = client.counter.getOrCreate(["live-counter"]);
const connection = counter.connect();

// Listen for events
connection.on("countChanged", (newCount: number) => );

// Call actions through the connection
const result = await connection.increment(1);

// Clean up when done
await connection.dispose();
```

## `ActorConn`

Real-time connections enable bidirectional communication between clients and actors through persistent connections. Rivet automatically negotiates between WebSocket (preferred for full duplex) and Server-Sent Events (SSE) as a fallback for restrictive environments.

For more information on connections, see the [connections documentation](/docs/actors/connections). For more information on handling events, see the [events documentation](/docs/actors/events).

### Calling Actions

You can also call actions through an `ActorConn`, just like with an `ActorHandle`:

```typescript
const connection = counter.connect();

// Call actions through the connection
const count = await connection.increment(5);
const currentValue = await connection.getCount();
```

### Reconnections

Connections automatically handle network failures with built-in reconnection logic:

- **Exponential backoff**: Retry delays increase progressively to avoid overwhelming the server
- **Action queuing**: Actions called while disconnected are queued and sent once reconnected
- **Event resubscription**: Event listeners are automatically restored on reconnection

### `on(eventName, callback)` - Listen for Events

Listen for events from the actor:

```typescript
// Listen for chat messages
connection.on("messageReceived", (message) => : $`);
});

// Listen for game state updates
connection.on("gameStateChanged", (gameState) => );

// Listen for player events
connection.on("playerJoined", (player) =>  joined the game`);
});
```

### `once(eventName, callback)` - Listen Once

Listen for an event only once:

```typescript
// Wait for game to start
connection.once("gameStarted", () => );
```

### `dispose()` - Clean Up Connection

Always dispose of connections when finished to free up resources:

```typescript
const connection = actor.connect();

try  finally 

// Or with automatic cleanup in React/frameworks
useEffect(() => ;
}, []);
```

**Important:** Disposing a connection:
- Closes the underlying WebSocket or SSE connection
- Removes all event listeners
- Cancels any pending reconnection attempts
- Prevents memory leaks in long-running applications

## Authentication

### Connection Parameters

Pass authentication data when connecting to actors:

```typescript
// With connection parameters
const chat = client.chatRoom.getOrCreate(["general"], 
});

const connection = chat.connect();

// Or for action calls
const result = await chat.sendMessage("Hello world!");
```

### onAuth Hook Validation

Actors can validate authentication using the `onAuth` hook:

```typescript
const protectedActor = actor( = opts;
    
    // Extract token from params or headers
    const token = params.authToken || req.headers.get("Authorization");
    
    if (!token) );
    }
    
    // Validate and return user data
    const user = await validateJWT(token);
    
    // Check permissions based on what the client is trying to do
    if (intents.has("create") && user.role !== "admin") );
    }
    
    return ;
  },
  
  actions:  = c.conn.auth;
      
      if (role !== "admin") );
      }
      
      return `Hello admin $`;
    }
  }
});
```

Learn more about [authentication patterns](/docs/actors/authentication).

## Type Safety

Rivet provides end-to-end type safety between clients and actors:

### Action Type Safety

TypeScript validates action signatures and return types:

```typescript
// TypeScript knows the action signatures
const counter = client.counter.getOrCreate(["my-counter"]);

const count: number = await counter.increment(5);   // ✓ Correct
const invalid = await counter.increment("5");       // ✗ Type error

// IDE autocomplete shows available actions
counter./*  */
```

### Client Type Safety

Import types from your registry for full type safety:

```typescript
// Client is fully typed
const client = createClient("http://localhost:8080");

// IDE provides autocomplete for all actors
client./*  */
```

## Best Practices

### `ActorHandle` (Stateless) vs `ActorConn` (Stateful) Clients

**Use `ActorHandle` (Stateless) For:**
- Simple request-response operations
- One-off operations  
- Server-side integration

```typescript
// Good for simple operations
const result = await counter.increment(1);
const status = await server.getStatus();
```

**Use `ActorConn` (Stateful) Connections For:**
- Real-time updates needed
- Event-driven interactions
- Long-lived client sessions

```typescript
// Good for real-time features
const connection = chatRoom.connect();
connection.on("messageReceived", updateUI);
await connection.sendMessage("Hello!");
```

### Resource Management

Always clean up connections when finished:

```typescript
// Manual cleanup
const connection = actor.connect();
try  finally 
```

### Error Handling

Handle connection errors using the `.onError()` method:

```typescript }
const connection = actor.connect();

connection.onError((error) =>  else if (error.code === 'ACTOR_NOT_FOUND') 
});
```

```tsx }
function ConnectionErrorHandler() );

  useEffect(() => , 5000);
    });

    // Clean up error handler when component unmounts
    return unsubscribe;
  }, [actor.connection]);

  // ...rest of component...
}
```

### Execute Actions in Parallel

You can execute batch requests in parallel:

```typescript
// Batch multiple operations through a connection
const connection = actor.connect();
await Promise.all([
  connection.operation1(),
  connection.operation2(),
  connection.operation3(),
]);

// Use getOrCreate for actors you expect to exist
const existing = client.counter.getOrCreate(["known-counter"]);

// Use create only when you need a fresh instance
const fresh = await client.counter.create(["new-counter"]);
```

However, it's recommended to move this logic to run within the actor instead of the client if executing multiple actions is a common pattern.
## Communicating Between Actors

# Communicating Between Actors

Learn how actors can call other actors and share data

Actors can communicate with each other using the server-side actor client, enabling complex workflows and data sharing between different actor instances.

We recommend reading the [clients documentation](/docs/actors/clients) first. This guide focuses specifically on communication between actors.

## Using the Server-Side Actor Client

The server-side actor client allows actors to call other actors within the same registry. Access it via `c.client()` in your actor context:

```typescript
const orderProcessor = actor(,
  
  actions: );
      
      return ;
    }
  }
});
```

## Use Cases and Patterns

### Actor Orchestration

Use a coordinator actor to manage complex workflows:

```typescript
const workflowActor = actor(,
  
  actions: );
      return result;
    }
  }
});
```

### Data Aggregation

Collect data from multiple actors:

```typescript
const analyticsActor = actor(,
  
  actions: ,
        generatedAt: Date.now()
      };
      
      c.state.reports.push(report);
      return report;
    }
  }
});
```

### Event-Driven Architecture

Use connections to listen for events from other actors:

```typescript
const auditLogActor = actor(,
  
  actions: );
      });
      
      // Listen for order events
      orderActor.on("orderCompleted", (order) => );
      });
      
      return ;
    }
  }
});
```

### Batch Operations

Process multiple items in parallel:

```typescript
// Process items in parallel
const results = await Promise.all(
  items.map(item => client.processor.getOrCreate([item.type]).process(item))
);
```
## Connections

# Connections

Connections represent client connections to your actor. They provide a way to handle client authentication, manage connection-specific data, and control the connection lifecycle.

## Parameters

When clients connect to an actor, they can pass connection parameters that are handled during the connection process.

For example:

```typescript }
const client = createClient("http://localhost:8080");
const gameRoom = await client.gameRoom.get(
});
```

```typescript }
const gameRoom = actor(,
  
  // Handle connection setup
  createConnState: (c, opts, params: ) => 
    
    // Create connection state
    return ;
  },
  
  actions: 
});
```

## Connection State

There are two ways to define an actor's connection state:

		Define connection state as a constant value:

		```typescript
		const chatRoom = actor(,
		  
		  // Define default connection state as a constant
		  connState: ,
		  
		  onConnect: (c) => ,
		  
		  actions: 
		});
		```

		This value will be cloned for every new connection using `structuredClone`.

		Create connection state dynamically with a function called for each connection:

		```typescript
		const chatRoom = actor(,
		  
		  // Create connection state dynamically
		  createConnState: (c) => ;
		  },
		  
		  actions: );
		      c.broadcast("newMessage", );
		    }
		  }
		});
		```

## Connection Lifecycle Hooks

The connection lifecycle has several hooks:

- `onBeforeConnect`: Called before a client connects, returns the connection state
- `onConnect`: Called when a client successfully connects
- `onDisconnect`: Called when a client disconnects

See the documentation on [Actor Lifecycle](/docs/actors/lifecycle) for more details.

## Connection List

All active connections can be accessed through the context object's `conns` property. This is an array of all current connections.

This is frequently used with `conn.send(name, event)` to send messages directly to clients.

For example:

```typescript
const chatRoom = actor( },
  
  actions: );
      }
    }
  }
});
```

## Disconnecting clients

Connections can be disconnected from within an action:

```typescript
const secureRoom = actor(,
  
  actions: 
    }
  }
});
```

If you need to wait for the disconnection to complete, you can use `await`:

```typescript
await c.conn.disconnect('Too many requests');
```

This ensures the underlying network connections close cleanly before continuing.

## Connection Error Handling

Handle connection errors using the `.onError()` method:

```typescript }
const connection = actor.connect();

connection.onError((error) =>  else if (error.code === 'ACTOR_NOT_FOUND') 
});
```

```tsx }
function ConnectionErrorHandler() );

  useEffect(() => , 5000);
    });

    // Clean up error handler when component unmounts
    return unsubscribe;
  }, [actor.connection]);

  // ...rest of component...
}
```

## Offline & Auto-Reconnection

See [client documentation](/docs/actors/communicating-between-actors) for details on reconnection behavior.
## Ephemeral Variables

# Ephemeral Variables

In addition to persisted state, Rivet provides a way to store ephemeral data that is not saved to permanent storage using `vars`. This is useful for temporary data that only needs to exist while the actor is running or data that cannot be serialized.

`vars` is designed to complement `state`, not replace it. Most actors should use both: `state` for critical business data and `vars` for ephemeral or non-serializable data.

## Initializing Variables

There are two ways to define an actor's initial vars:

Define an actor vars as a constant value:

```typescript
// Define vars as a constant
const counter = actor(,
  
  // Define ephemeral variables
  vars: ,
  
  actions: 
});
```

This value will be cloned for every new actor using `structuredClone`.

Create actor state dynamically on each actors' start:

```typescript
// Define vars with initialization logic
const counter = actor(,
  
  // Define vars using a creation function
  createVars: (c: ActorInitContext, driver: any) => ;
  },
  
  actions: 
});
```

If accepting arguments to `createVars`, you **must** define the types: `createVars(c: ActorInitContext, driver: any)`

Otherwise, the return type will not be inferred and `c.vars` will be of type `unknown`.

## Using Variables

Vars can be accessed and modified through the context object with `c.vars`:

```typescript
const counter = actor(,
  
  // Create ephemeral objects that won't be serialized
  createVars: () => `);
    });
    
    return ;
  },
  
  actions: 
  }
});
```

## When to Use `vars` vs `state`

In practice, most actors will use both: `state` for critical business data and `vars` for ephemeral or non-serializable data.

Use `vars` when:

- You need to store temporary data that doesn't need to survive restarts
- You need to maintain runtime-only references that can't be serialized (database connections, event emitters, class instances, etc.)

Use `state` when:

- The data must be preserved across actor sleeps, restarts, updates, or crashes
- The information is essential to the actor's core functionality and business logic

## Advanced

### Accessing Driver Context

The `createVars` function receives a second parameter that provides access to driver-specific context. This allows you to access driver-specific functionality.

For example, the Redis driver exposes access to the Redis instance:

```typescript
const myActor = actor(,
  
  // The second parameter provides driver-specific context
  createVars: (ctx: ActorInitContext, driver: DriverContext) => (),
  
  actions: 
  }
});
```

Consult the documentation for each driver to learn more about their respective `DriverContext` types.
## Events

# Events

Events enable real-time communication from actors to clients. While clients use actions to send data to actors, events allow actors to push updates to connected clients instantly.

Events work through persistent connections such as WebSocket or SSE.

## Publishing Events from Actors

### Broadcasting to All Clients

Use `c.broadcast(eventName, data)` to send events to all connected clients:

```typescript
const chatRoom = actor(,
  
  actions: ;
      
      c.state.messages.push(message);
      
      // Broadcast to all connected clients
      c.broadcast('messageReceived', message);
      
      return message;
    },
  }
});
```

### Sending to Specific Connections

Send events to individual connections using `conn.send(eventName, data)`:

```typescript
const gameRoom = actor( as Record
  },
  
  createConnState: (c, opts, params: ) => (),
  
  actions: );
      } else 
    }
  }
});
```

Send events to all connections except the sender:

```typescript
const gameRoom = actor( as Record
  },
  
  createConnState: (c, opts, params: ) => (),
  
  actions: ) => );
          }
        }
      }
    }
  }
});
```

## Subscribing to Events from Clients

Clients must establish a connection to receive events from actors. Use `.connect()` to create a persistent connection, then listen for events.

### Basic Event Subscription

Use `connection.on(eventName, callback)` to listen for events:

```typescript }
const client = createClient("http://localhost:8080");

// Get actor handle and establish connection
const chatRoom = client.chatRoom.getOrCreate(["general"]);
const connection = chatRoom.connect();

// Listen for events
connection.on('messageReceived', (message) => : $`);
  displayMessage(message);
});

// Call actions through the connection
await connection.sendMessage("user-123", "Hello everyone!");
```

```tsx }
function ChatRoom() );

  // Listen for events
  chatRoom.useEvent("messageReceived", (message) => );

  // ...rest of component...
}
```

### One-time Event Listeners

Use `connection.once(eventName, callback)` for events that should only trigger once:

```typescript }
const gameRoom = client.gameRoom.getOrCreate(["room-456"]);
const connection = gameRoom.connect();

// Listen for game start (only once)
connection.once('gameStarted', () => );
```

```tsx }
function GameLobby() 
  });

  // Listen for game start (only once)
  useEffect(() => ;

    gameRoom.connection.once('gameStarted', handleGameStart);
  }, [gameRoom.connection]);

  // ...rest of component...
}
```

### Removing Event Listeners

Use the callback returned from `.on()` to remove event listeners:

```typescript }
// Add listener
const unsubscribe = connection.on('messageReceived', (message) => );

// Remove listener
unsubscribe();
```

```tsx }
function ConditionalListener() );

  useEffect(() => : $`]);
    });

    // Cleanup - remove listener when component unmounts or listening stops
    return () => ;
  }, [chatRoom.connection, isListening]);

  // ...rest of component...
}
```

## More About Connections

For more details on actor connections, including connection lifecycle, authentication, and advanced connection patterns, see the [Connections documentation](/docs/actors/connections).
## External SQL Database

# External SQL Database

While actors can serve as a complete database solution, they can also complement your existing databases. For example, you might use actors to handle frequently-changing data that needs real-time access, while keeping less frequently accessed data in your traditional database.

Actors can be used with common SQL databases, such as PostgreSQL and MySQL.

## Libraries

To facilitate interaction with SQL databases, you can use either ORM libraries or raw SQL drivers. Each has its own use cases and benefits:

-   **ORM Libraries**: Type-safe and easy way to interact with your database

    -   [Drizzle](https://orm.drizzle.team/)
    -   [Prisma](https://www.prisma.io/)

-   **Raw SQL Drivers**: Direct access to the database for more flexibility

    -   [PostgreSQL](https://node-postgres.com/)
    -   [MySQL](https://github.com/mysqljs/mysql)

## Hosting Providers

There are several options for places to host your SQL database:

-   [Supabase](https://supabase.com/)
-   [Neon](https://neon.tech/)
-   [PlanetScale](https://planetscale.com/)
-   [AWS RDS](https://aws.amazon.com/rds/)
-   [Google Cloud SQL](https://cloud.google.com/sql)

## Examples

### Basic PostgreSQL Connection

Here's a basic example of a user actor that creates a database record on start and tracks request counts:

```typescript }
interface ActorInput 

// Create a database connection pool
const pool = new Pool();

// Create the user actor
const userActor = actor(),
  
  // Insert user into database when actor starts
  onStart: async (c, opts) => ,
  
  actions: ;
    },
    
    // Get user data
    getUser: async (c) => ;
    }
  }
});

const registry = setup(,
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Create user
const alice = await client.userActor.create("alice", 
});

alice.updateUser("alice2@example.com");

const userData = await alice.getUser();
console.log("User data:", userData);

// Create another user
const bob = await client.userActor.create("bob", 
});
const bobData = await bob.getUser();
```

### Using Drizzle ORM

Here's the same user actor pattern using Drizzle ORM for more type-safe database operations:

```typescript }
interface ActorInput 

// Define your schema
const users = pgTable("users", );

// Create a database connection
const pool = new Pool();

// Initialize Drizzle with the pool
const db = drizzle(pool);

// Create the user actor
const userActor = actor(),
  
  // Insert user into database when actor starts
  onStart: async (c, opts) => );
  },
  
  actions: )
        .where(eq(users.username, c.state.username));
      
      return ;
    },
    
    // Get user data
    getUser: async (c) => ;
    }
  }
});

const registry = setup(,
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Create user
const alice = await client.userActor.create("alice", 
});

alice.updateUser("alice2@example.com");

const userData = await alice.getUser();
console.log("User data:", userData);

// Create another user
const bob = await client.userActor.create("bob", 
});
const bobData = await bob.getUser();
```
## Fetch and WebSocket Handler

# Fetch and WebSocket Handler

Actors can handle HTTP requests and WebSocket connections through the `onFetch` and `onWebSocket` handlers.

For most use cases, [actions](/docs/actors/actions) and [events](/docs/actors/events) provide high-level connection handling that's easier to work with. However, raw handlers are required when implementing custom use cases or integrating external libraries that need direct access to the underlying HTTP `Request`/`Response` objects or WebSocket connections.

## Defining Handlers

### `onFetch(c, request, )`

The `onFetch` handler processes HTTP requests sent to your actor. It receives the actor context and a standard `Request` object.

WebSocket upgrades are not currently supported in `onFetch`. Use `onWebSocket` instead.

```typescript
const httpActor = actor(,
    actions: ,
    onFetch(ctx, request) ), ,
            });
        }

        if (url.pathname === "/api/echo" && request.method === "POST") );
        }

        // Return 404 for unhandled paths
        return new Response("Not Found", );
    },
});
```

```typescript
function buildRouter(ctx: ActorContext) );
    });

    app.post("/api/echo", async (c) => );

    app.get("/api/stats", (c) => );
    });

    return app;
}

const honoActor = actor(,
    createVars(ctx) ;
    },
    actions: ,
    async onFetch(ctx, request) ,
});
```

Also see the [raw fetch handler example project](https://github.com/rivet-dev/rivetkit/tree/main/examples/raw-fetch-handler).

	`onFetch` can be used to expose Server-Sent Events from Rivet Actors.

### `onWebSocket(c, websocket, )`

The `onWebSocket` handler manages WebSocket connections. It receives the actor context, a `WebSocket` object, and the initial `Request`.

```typescript
const websocketActor = actor(,
    actions: ,
    onWebSocket(ctx, websocket) ));

        websocket.addEventListener("message", (event) => );
    },
});
```

Also see the [raw WebSocket handler with proxy example project](https://github.com/rivet-dev/rivetkit/tree/main/examples/raw-websocket-handler-proxy).

	Connection lifecycle hooks like `onConnect` and `onDisconnect` do not get called when opening WebSockets for `onWebSocket`. This is because `onWebSocket` provides a low-level connection. Use `ws.addEventListener("open")` and `ws.addEventListener("close")` instead.

## Accessing Your Handlers

There are three ways to access your actor's fetch and WebSocket handlers:

### Option A: From Backend via RivetKit Client

You can use the RivetKit client's built-in methods for raw HTTP and WebSocket access:

```typescript
const client = createClient("http://localhost:8080");

// HTTP requests using .fetch() method
const actor = client.myActor.getOrCreate(["key"]);
const response = await actor.fetch("/api/hello", );
const data = await response.json();

// POST request with JSON body
const postResponse = await actor.fetch("/api/echo", ,
    body: JSON.stringify(),
});
```

```typescript
const client = createClient("http://localhost:8080");

// WebSocket connections using .websocket() method
const actor = client.myActor.getOrCreate(["key"]);
const ws = await actor.websocket("/custom/path");

// Listen for messages
ws.addEventListener("message", (event) =>  else if (message.type === "echo")  else if (message.type === "pong") 
});

// Send messages
ws.send(JSON.stringify());

// Send ping
ws.send(JSON.stringify());
```

For more advanced use cases, you can forward requests to actor handlers from your server:

```typescript
const  = registry.start();

const app = new Hono();

// Forward requests to actor's fetch handler
app.all("/forward/:name/*", async (c) => `, "");
    const url = new URL(truncatedPath, c.req.url);
    const newRequest = new Request(url, c.req.raw);
    
    // Forward to actor's fetch handler
    const actor = client.counter.getOrCreate(name);
    const response = await actor.fetch(truncatedPath, newRequest);
    
    return response;
});

serve(app);
```

```typescript
const  = registry.start();

const app = new Hono();

// Forward WebSocket connections to actor's WebSocket handler
app.get("/ws/:name", upgradeWebSocket(async (c) => );

            actorWs.addEventListener("close", () => );
        },
        onMessage: (evt, ws) => ,
        onClose: (evt, ws) => ,
    };
}));

serve(app);
```

### Option B: From Frontend with RivetKit Client

Use the RivetKit client to make direct HTTP requests or WebSocket connections:

```typescript
const client = createClient("http://localhost:8080");

// HTTP requests
const actor = client.myActor.getOrCreate(["key"]);
const response = await actor.fetch("/api/hello", );
const data = await response.json();
console.log(data); // 

// POST request with data
const postResponse = await actor.fetch("/api/echo", ,
    body: JSON.stringify(),
});

// Handle response
if (postResponse.ok)  else 
```

```typescript
const client = createClient("http://localhost:8080");

// WebSocket connections
const actor = client.myActor.getOrCreate(["key"]);
const ws = await actor.websocket("/");

// Listen for messages
ws.addEventListener("message", (event) => );
            break;
            
        case "echo":
            console.log("Echo received:", message.data);
            displayMessage(message.data);
            break;
            
        case "pong":
            console.log("Pong received, latency:", Date.now() - message.timestamp);
            break;
            
        case "error":
            console.error("Error:", message.message);
            break;
    }
});

// Send messages
function sendMessage(text) ));
}

// Ping for latency testing
function ping() ));
}

// Handle connection errors
ws.addEventListener("error", (event) => );

ws.addEventListener("close", () => );
```

	The `.websocket()` method returns a barebones WebSocket. Unlike [actor connections](/docs/actors/connections), it does not provide automatic reconnection logic. You must implement reconnection logic yourself if needed.

### Option C: From Frontend via Direct RivetKit Router Access

You can access your actor handlers directly through the mounted RivetKit router. The router automatically handles the required headers for authentication and routing.

For HTTP requests, the router expects these headers:
- `X-RivetKit-Actor-Query`: JSON-encoded actor query
- `X-RivetKit-Encoding`: Encoding type (usually "json")
- `X-RivetKit-Conn-Params`: JSON-encoded connection parameters (optional)

```typescript
// Direct HTTP request to actor
const response = await fetch("http://localhost:8080/registry/actors/myActor/raw/http/api/hello", 
        }),
        "X-RivetKit-Encoding": "json",
        "X-RivetKit-Conn-Params": JSON.stringify()
    }
});

const data = await response.json();
console.log(data); // 

// POST request with data
const postResponse = await fetch("http://localhost:8080/registry/actors/myActor/raw/http/api/echo", 
        }),
        "X-RivetKit-Encoding": "json",
        "X-RivetKit-Conn-Params": JSON.stringify(),
        "Content-Type": "application/json"
    },
    body: JSON.stringify()
});

// Handle response
if (postResponse.ok)  else 
```

For WebSocket connections, authentication data is passed via WebSocket subprotocols:

```typescript
// Direct WebSocket connection to actor
const protocols = [
    `query.$
    }))}`,
    `encoding.json`,
    `conn_params.$))}`
];

const ws = new WebSocket("ws://localhost:8080/registry/actors/myActor/ws/", protocols);

// Listen for messages
ws.addEventListener("message", (event) => );
            
            // Send initial message
            ws.send(JSON.stringify());
            break;
            
        case "echo":
            console.log("Echo received:", message.data);
            break;
            
        case "pong":
            console.log("Pong received, latency:", Date.now() - message.timestamp);
            break;
            
        case "error":
            console.error("WebSocket error:", message.message);
            break;
    }
});

// Send ping for latency testing
function sendPing() ));
}

// Handle connection events
ws.addEventListener("open", () => );

ws.addEventListener("error", (event) => );

ws.addEventListener("close", (event) => );
```

	For Cloudflare Workers, you must include `"rivetkit"` as a protocol when using raw WebSockets:
	
	```typescript
	const protocols = [
	    "rivetkit", // Required for Cloudflare Workers
	    `query.$
	    }))}`,
	    `encoding.json`
	];
	```

## Authentication

If you are using the external client, authentication is handled through the `onAuth` handler. The `onAuth` handler is executed on the server before the request is sent to the actor, reducing resource load on the actor by filtering out unauthorized requests early.

If you are using the server-side client, then authentication is skipped by default.

See the [authentication documentation](/docs/actors/authentication) for detailed information on implementing authentication patterns.

## State Saves

State changes in `onFetch` and `onWebSocket` handlers are automatically saved after the handler finishes executing.

For `onWebSocket` handlers specifically, you'll need to manually save state using `c.saveState()` while the WebSocket connection is open if you want state changes to be persisted immediately. This is because WebSocket connections can remain open for extended periods, and state changes made during event handlers (like `message` events) won't be automatically saved until the connection closes.

```typescript
const websocketActor = actor(,
    actions: ,
    onWebSocket(ctx, websocket) ));
        });
    },
});
```

For more details on state management, see [State](/docs/actors/state).

## W3C Compliance

It's not possible to use the global `fetch` method or global WebSocket class to connect to an actor. This is because actors do not have traditional network interfaces to communicate with.

However, the `Request`, `Response`, and `WebSocket` types used with `.fetch()` and `.websocket()` comply with the W3C specification and will work wherever you pass them.
## Helper Types

# Helper Types

Rivet provides several TypeScript helper types to make it easier to work with actors in a type-safe way.

## `Context` Types

When working with actors, you often need to access the context object outside of the actor's handlers. Rivet provides helper types to extract the context types from actor definitions.

### `ActorContextOf`

Extracts the full actor context type from an actor definition. This is the type of the context object (`c`) available in [lifecycle hooks](/docs/actors/lifecycle) and in [actions](/docs/actors/actions).

```typescript
const chatRoom = actor(,
  actions: ,
  actions: 
  }
});

// Now you can use this type elsewhere
function logMessage(context: ActorContextOf, message: string) );
}
```

### `ActionContextOf`

Extracts the action context type from an actor definition. This is the type of the context object (`c`) available in [actions](/docs/actors/actions). This cannot be used in [lifecycle hooks](/docs/actors/lifecycle).

```typescript
const counterWithProcessing = actor(,
  actions: 
  }
});

function processCounterAction(context: ActionContextOf) 
```
## Overview

# Overview

Actors for long-lived processes with durable state, realtime, and hibernate when not in use.

## Quickstart

  Set up Rivet with Node.js, Bun, and web frameworks

  Set up Rivet with React

  Set up Rivet with Next.js

  Set up Rivet with Cloudflare Workers

## Features

- **Long-Lived, Stateful Compute**: Each unit of compute is like a tiny server that remembers things between requests – no need to re-fetch data from a database or worry about timeouts. Like AWS Lambda, but with memory and no timeouts.
- **Blazing-Fast Reads & Writes**: State is stored on the same machine as your compute, so reads and writes are ultra-fast. No database round trips, no latency spikes.
- **Realtime**: Update state and broadcast changes in realtime with WebSockets or SSE. No external pub/sub systems, no polling – just built-in low-latency events.
- **Infinitely Scalable**: Automatically scale from zero to millions of concurrent actors. Pay only for what you use with instant scaling and no cold starts.
- **Fault Tolerant**: Built-in error handling and recovery. Actors automatically restart on failure while preserving state integrity and continuing operations.

## Use Cases

Actors are perfect for applications that need persistent state and real-time updates:

- **AI agents**: Stateful AI assistants with conversation history
- **Collaborative documents**: Multiple users editing documents simultaneously (Yjs integration)
- **Local-first sync**: Offline-first applications with server synchronization
- **Per-tenant databases**: Isolated data stores for each user or tenant
- **Background job**: Background & time-based task execution with persistent state
- **Rate limiting**: Distributed rate limiting with persistent counters
- **Stream processing**: Real-time data processing with persistent state

## Core Concepts

### State Management

Actors maintain persistent state that survives restarts, crashes, and deployments. State can be defined as a constant or created dynamically:

```typescript
const counter = actor(,
  
  actions: ,
    
    getCount: (c) => c.state.count,
  }
});
```

Learn more about [state management](/docs/actors/state).

### Actions

Actions are the primary way to interact with actors. They're type-safe functions that can modify state and communicate with clients:

```typescript
const chatRoom = actor(,
  
  actions: ;
      c.state.messages.push(message);
      c.broadcast("newMessage", message);
      return message;
    },
    
    getMessages: (c) => c.state.messages
  }
});
```

Actions can be called from your backend, your clients, or other actors:

```typescript
const room = client.chatRoom.getOrCreate(["general"]);
const message = await room.sendMessage("user-123", "Hello everyone!");
```

Learn more about [actions](/docs/actors/actions) and [communicating with actors](/docs/actors/communicating-between-actors).

### Real-time Communication & Events

Actors support real-time bidirectional communication through WebSocket and SSE connections. Clients can establish persistent connections to receive live updates.

For example, to send events to all connected clients:

```typescript
const liveAuction = actor(,
  
  actions: );
      return amount;
    }
  }
});
```

Clients connect and listen for real-time updates:

```typescript
const auction = client.liveAuction.getOrCreate(["auction-123"]);
const connection = auction.connect();

connection.on("newBid", (data) => `);
});

await auction.placeBid(150);
```

Learn more about [events](/docs/actors/events) and [client communication](/docs/actors/communicating-between-actors).

### Scheduling & Lifecycle

Actors support scheduled tasks and lifecycle management:

```typescript
const reminder = actor(,
  
  actions: ,
    
    sendReminder: (c) => );
    }
  }
});
```

Learn more about [actor lifecycle](/docs/actors/lifecycle).

### Type Safety

Rivet provides end-to-end TypeScript safety between clients and actors:

```typescript }
const userManager = actor( as Record },
  
  actions: ;
      return ;
    },
    
    getUser: (c, userId: string) => c.state.users[userId]
  }
});
```

```typescript }
const manager = client.userManager.getOrCreate(["default"]);

const user = await manager.createUser("Alice");
// Type: 

const foundUser = await manager.getUser(user.userId);
// Type:  | undefined
```

## Frequently Asked Questions

        Some software makes sense to separate – e.g., for data lakes or highly relational data. But at the end of the day, data has to be partitioned somewhere at some point.

        Usually "faster" databases like Cassandra, DynamoDB, or Vitess make consistency tradeoffs to get better performance. Stateful serverless forces you to think about how your data is sharded for better performance, better scalability, and less consistency footguns.

        See [Sharing and Joining State](/docs/actors/sharing-and-joining-state) for detailed strategies on combining data from multiple actors.

        OLAP, data lakes, graph databases, and highly relational data are currently not ideal use cases for the actor model.

        Yes, but only in the same way that storing data in a single database row creates a bottleneck.

		Just like a single database row can cause contention when multiple clients try to read and write the same data, a single actor can become a bottleneck if too many requests target it.

		The solution is the same: shard your data across multiple actors to distribute the load and scale seamlessly.

		However, actors handle much higher throughput than traditional database rows because they keep data in memory, making read and write operations significantly faster.
## Input Parameters

# Input Parameters

Pass initialization data to actors when creating instances

Actors can receive input parameters when created, allowing for flexible initialization and configuration. Input is passed during actor creation and is available in lifecycle hooks.

## Passing Input to Actors

Input is provided when creating actor instances using the `input` property:

```typescript
// Client side - create with input
const game = await client.game.create(["game-123"], 
});

// getOrCreate can also accept input (used only if creating)
const gameHandle = client.game.getOrCreate(["game-456"], 
});
```

## Accessing Input in Lifecycle Hooks

Input is available in lifecycle hooks via the `opts.input` parameter:

```typescript
interface ChatRoomInput 

const chatRoom = actor(,
    messages: [],
  }),
  
  onCreate: (c, opts, input: ChatRoomInput) => `);
    
    // Setup external services based on input
    if (input.isPrivate) 
  },
  
  actions: ),
  },
});
```

## Input Validation

You can validate input parameters in the `createState` or `onCreate` hooks:

```typescript
const GameInputSchema = z.object();

const game = actor(,
      gameState: "waiting",
    };
  },
  
  actions: ),
  },
});
```

## Input vs Connection Parameters

Input parameters are different from connection parameters:

- **Input**:
  - Passed when creating the actor instance
  - Use for actor-wide configuration
  - Available in lifecycle hooks
- **Connection parameters**:
  - Passed when connecting to an existing actor
  - Used for connection-specific configuration
  - Available in connection hooks

```typescript
// Actor creation with input
const room = await client.chatRoom.create(["room-123"], ,
  params: 
});
```

## Input Best Practices

### Use Type Safety

Define input types to ensure type safety:

```typescript
interface GameInput 

const game = actor(),
  
  actions: ,
});
```

### Store Input in State

If you need to access input data in actions, store it in the actor's state:

```typescript
const game = actor(,
    // Runtime state
    players: ,
    gameState: "waiting",
  }),
  
  actions: ,
  },
});
```
## Actor Keys

# Actor Keys

Actor keys uniquely identify actor instances within each actor type. Keys are used for addressing which specific actor to communicate with.

## Key Format

Actor keys can be either a string or an array of strings:

```typescript
// String key
const counter = client.counter.getOrCreate("my-counter");

// Array key (compound key)
const chatRoom = client.chatRoom.getOrCreate(["room", "general"]);
```

### Compound Keys & User Data

Array keys are useful when you need compound keys with user-provided data. Using arrays makes adding user data safe by preventing key injection attacks:

```typescript
// User-specific chat rooms
const userRoom = client.chatRoom.getOrCreate(["user", userId, "private"]);

// Game rooms by region and difficulty
const gameRoom = client.gameRoom.getOrCreate(["us-west", "hard", gameId]);

// Multi-tenant resources
const workspace = client.workspace.getOrCreate(["tenant", tenantId, workspaceId]);
```

This allows you to create hierarchical addressing schemes and organize actors by multiple dimensions.

Don't build keys using string interpolation like `"foo:$:bar"` when `userId` contains user data. If a user provides a value containing the delimiter (`:` in this example), it can break your key structure and cause key injection attacks.

### Omitting Keys

You can create actors without specifying a key in situations where there is a singleton actor (i.e. only one actor of a given type). For example:

```typescript
// Get the singleton session
const globalActor = client.globalActor.getOrCreate();
```

This pattern should be avoided, since a singleton actor usually means you have a single actor serving all traffic & your application will not scale. See [scaling documentation](/docs/actors/scaling) for more information.

### Key Uniqueness

Keys are unique within each actor name. Different actor types can use the same key:

```typescript
// These are different actors, same key is fine
const userChat = client.chatRoom.getOrCreate(["user-123"]);
const userProfile = client.userProfile.getOrCreate(["user-123"]);
```

## Accessing Keys in Metadata

Access the actor's key within the actor using the [metadata](/docs/actors/metadata) API:

```typescript }
const chatRoom = actor(
  }
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

async function connectToRoom(roomName: string) 

// Usage example
const generalRoom = await connectToRoom("general");
```

## Configuration Examples

### Simple Configuration with Keys

Use keys to provide basic actor configuration:

```typescript }
const userSession = actor(
  }),
  
  actions: 
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Pass user ID in the key for user-specific actors
const userSession = client.userSession.getOrCreate([userId]);
```

### Complex Configuration with Input

For more complex configuration, use [input parameters](/docs/actors/input):

```typescript }
const client = createClient("http://localhost:8080");

// Create with both key and input
const chatRoom = await client.chatRoom.create(["room", roomName], 
  }
});
```
## Lifecycle

# Lifecycle

Understand actor lifecycle hooks and initialization patterns

Actors follow a well-defined lifecycle with hooks at each stage. Understanding these hooks is essential for proper initialization, state management, and cleanup.

## Lifecycle Hooks

Actor lifecycle hooks are defined as functions in the actor configuration.

### `createState` and `state`

The `createState` function or `state` constant defines the initial state of the actor (see [state documentation](/docs/actors/state)). The `createState` function is called only once when the actor is first created.

### `createVars` and `vars`

The `createVars` function or `vars` constant defines ephemeral variables for the actor (see [state documentation](/docs/actors/state)). These variables are not persisted and are useful for storing runtime-only objects or temporary data.

The `createVars` function can also receive driver-specific context as its second parameter, allowing access to driver capabilities like Rivet KV or Cloudflare Durable Object storage.

```typescript
// In this example, assume we're using Redis
// Using vars constant
const counter1 = actor(,
  vars: ,
  actions: 
});

// Using createVars function
const counter2 = actor(,
  createVars: () => ;
  },
  actions: 
});

// Access driver-specific context
const exampleActor = actor(,
  // Access driver context in createVars
  createVars: (c: ActorInitContext, driverCtx: DriverContext) => (),
  actions: 
  }
});
```

### `onCreate`

The `onCreate` hook is called at the same time as `createState`, but unlike `createState`, it doesn't return any value. Use this hook for initialization logic that doesn't affect the initial state.

```typescript
// Using state constant
const counter1 = actor(,
  actions: 
});

// Using createState function
const counter2 = actor(;
  },
  actions: 
});

// Using onCreate
const counter3 = actor(,
  
  // Run initialization logic (logging, external service setup, etc.)
  onCreate: (c, opts, input: ) => ,
  
  actions: 
});
```

### `onStart`

This hook is called any time the actor is started (e.g. after restarting, upgrading code, or crashing).

This is called after the actor has been initialized but before any connections are accepted.

Use this hook to set up any resources or start any background tasks, such as `setInterval`.

```typescript
const counter = actor(,
  vars: ,
  
  onStart: (c) => , 10000);
    
    // Store interval ID in vars to clean up later if needed
    c.vars.intervalId = intervalId;
  },
  
  actions: 
    }
  }
});
```

### `onStateChange`

Called whenever the actor's state changes. This is often used to broadcast state updates.

```typescript
const counter = actor(,
  
  onStateChange: (c, newState) => );
  },
  
  actions: 
  }
});
```

### `createConnState` and `connState`

There are two ways to define the initial state for connections:
1. `connState`: Define a constant object that will be used as the initial state for all connections
2. `createConnState`: A function that dynamically creates initial connection state based on connection parameters

### `onBeforeConnect`

The `onBeforeConnect` hook is called whenever a new client connects to the actor. Clients can pass parameters when connecting, accessible via `params`. This hook is used for connection validation and can throw errors to reject connections.

The `onBeforeConnect` hook does NOT return connection state - it's used solely for validation.

```typescript
const chatRoom = actor(,
  
  // Method 1: Use a static default connection state
  connState: ,
  
  // Method 2: Dynamically create connection state
  createConnState: (c, opts, params: ) => ;
  },
  
  // Validate connections before accepting them
  onBeforeConnect: (c, opts, params: ) => 
    
    // Authentication is valid, connection will proceed
    // The actual connection state will come from connState or createConnState
  },
  
  actions: 
});
```

Connections cannot interact with the actor until this method completes successfully. Throwing an error will abort the connection. This can be used for authentication - see [Authentication](/docs/actors/authentication) for details.

### `onConnect`

Executed after the client has successfully connected.

```typescript
const chatRoom = actor(, messages: [] },
  
  onConnect: (c) => ;
    
    // Broadcast that a user joined
    c.broadcast("userJoined", );
    
    console.log(`User $ connected`);
  },
  
  actions: 
});
```

Messages will not be processed for this actor until this hook succeeds. Errors thrown from this hook will cause the client to disconnect.

### `onDisconnect`

Called when a client disconnects from the actor. Use this to clean up any connection-specific resources.

```typescript
const chatRoom = actor(, messages: [] },
  
  onDisconnect: (c) => 
    
    // Broadcast that a user left
    c.broadcast("userLeft", );
    
    console.log(`User $ disconnected`);
  },
  
  actions: 
});
```

### `onFetch`

The `onFetch` hook handles HTTP requests sent to your actor. It receives the actor context and a standard `Request` object, and should return a `Response` object or `void` to continue default routing.

```typescript
const apiActor = actor(,
  
  onFetch: (c, request) => ), 
      });
    }
    
    // Return void to continue to default routing
    return;
  },
  
  actions: 
});
```

### `onWebSocket`

The `onWebSocket` hook handles WebSocket connections to your actor. It receives the actor context, a `WebSocket` object, and the initial `Request`. Use this to set up WebSocket event listeners and handle real-time communication.

```typescript
const realtimeActor = actor(,
  
  onWebSocket: (c, websocket, request) => ));
    
    // Handle incoming messages
    websocket.addEventListener("message", (event) => ));
      }
    });
    
    // Handle connection close
    websocket.addEventListener("close", () => );
  },
  
  actions: 
});
```

### `onAuth`

The `onAuth` hook is called on the HTTP server before clients can interact with the actor. This hook is required for any public HTTP endpoint access and is used to validate client credentials and return authentication data that will be available on connections.

This hook runs on the HTTP server (not the actor) to reduce load and prevent denial of service attacks against individual actors. Only called for public endpoints - calls to actors from within the backend do not trigger this handler.

```typescript
const secureActor = actor() => 
    
    const token = authHeader.slice(7);
    
    // Validate token with your auth service
    const user = await validateAuthToken(token);
    if (!user) 
    
    // Return auth data (must be serializable)
    return ;
  },
  
  state:  },
  
  onConnect: (c) =>  with role $ connected`);
    
    c.state.activeUsers[userId] = ;
  },
  
  actions: 
      
      return ;
    }
  }
});
```

### `onBeforeActionResponse`

The `onBeforeActionResponse` hook is called before sending an action response to the client. Use this hook to modify or transform the output of an action before it's sent to the client. This is useful for formatting responses, adding metadata, or applying transformations to the output.

```typescript
const loggingActor = actor(,
  
  onBeforeActionResponse: (c, actionName, args, output) =>  called with args:`, args);
    console.log(`Action $ returned:`, output);
    
    // Add metadata to all responses
    return 
    };
  },
  
  actions: ,
        lastActive: Date.now()
      };
    },
    
    getStats: (c) => ;
    }
  }
});
```

## Destroying Actors

_Destroying actors is not available yet._

## Advanced

### Running Background Tasks

The `c.runInBackground` method allows you to execute promises asynchronously without blocking the actor's main execution flow. The actor is prevented from sleeping while the promise passed to `runInBackground` is still active. This is useful for fire-and-forget operations where you don't need to wait for completion.

Common use cases:
- **Analytics and logging**: Send events to external services without delaying responses
- **State sync**: Populate external databases or APIs with updates to actor state in the background

```typescript
const gameRoom = actor(, scores:  },
  
  actions: ;
      
      // Send analytics event without blocking
      c.runInBackground(
        fetch('https://analytics.example.com/events', )
        }).then(() => console.log('Analytics sent'))
      );
      
      return ;
    },
  }
});
```

### Using `ActorContext` Type Externally

When extracting logic from lifecycle hooks or actions into external functions, you'll often need to define the type of the context parameter. Rivet provides helper types that make it easy to extract and pass these context types to external functions.

```typescript
const myActor = actor(,
  
  // Use external function in lifecycle hook
  onStart: (c) => logActorStarted(c)
});

// Simple external function with typed context
function logActorStarted(c: ActorContextOf) `);
}
```

See [Helper Types](/docs/actors/helper-types) for more details on using `ActorContextOf`.

## Full Example

```typescript
interface CounterInput 

const counter = actor(
    
    const token = authHeader.slice(7);
    const user = await validateAuthToken(token);
    if (!user) 
    
    return ;
  },
  
  // Initialize state with input
  createState: (c: ActorInitContext, input: CounterInput) => (),
  
  // Initialize actor (run setup that doesn't affect initial state)
  onCreate: (c, opts, input: ) => " initialized`);
    // Set up external resources, logging, etc.
  },
  
  // Define default connection state
  connState: ,
  
  createConnState: (c, opts) => ;
  },
  
  // Lifecycle hooks
  onStart: (c) => " started with count:`, c.state.count);
  },
  
  onStateChange: (c, newState) => );
  },
  
  onBeforeConnect: (c, ) =>  attempting to connect`);
  },
  
  onConnect: (c) =>  connected to "$"`);
  },
  
  onDisconnect: (c) =>  disconnected from "$"`);
  },
  
  // Transform all action responses
  onBeforeActionResponse: (c, actionName, args, output) => 
    };
  },
  
  // Define actions
  actions: ,
    
    reset: (c) => 
      
      c.state.count = 0;
      return c.state.count;
    },
    
    getInfo: (c) => (),
  }
});

default counter;
```
## Metadata

# Metadata

Metadata provides information about the currently running actor.

## Actor ID

Get the unique instance ID of the actor:

```typescript
const actorId = c.actorId;
```

## Actor Name

Get the actor type name:

```typescript
const actorName = c.name;
```

This is useful when you need to know which actor type is running, especially if you have generic utility functions that are shared between different actor implementations.

## Actor Key

Get the actor key used to identify this actor instance:

```typescript
const actorKey = c.key;
```

The key is used to route requests to the correct actor instance and can include parameters passed when creating the actor.

Learn more about using keys for actor addressing and configuration in the [keys documentation](/docs/actors/keys).

## Region

Region can be accessed from the context object via `c.region`.

```typescript
const region = c.region;
```

`c.region` is only supported on Rivet at the moment.

## Example Usage

```typescript }
const chatRoom = actor(,
  
  actions: ;
    }
  }
});

const registry = setup(
});
```

```typescript }
const client = createClient("http://localhost:8080");

// Connect to a chat room
const chatRoom = await client.chatRoom.get("general");

// Get actor metadata
const metadata = await chatRoom.getMetadata();
console.log("Actor metadata:", metadata);
```
## Node.js & Bun Quickstart

# Node.js & Bun Quickstart

Get started with Rivet Actors in Node.js and Bun

```sh
npm install rivetkit
```

Create a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
	},
});

const registry = setup(,
});
```

Choose your preferred web framework:

```ts }
// Start Rivet
const  = registry.start();
```

```ts }
// Start Rivet
const  = registry.start();

// Setup Hono app
const app = new Hono();

// Example API endpoint
app.post("/increment/:name", async (c) => );
});

// Start server
serve(app);
```

```ts }
// Start Rivet
const  = registry.start();

// Setup Express app
const app = express();
app.use(express.json());

// Example API endpoints
app.post("/increment/:name", async (req, res) =>  = req.params;

      const counter = client.counter.getOrCreate(name);
      const newCount = await counter.increment(1);
      
      res.json();
});

app.listen(8080, () => );
```

```ts }
// Start Rivet
const  = registry.start();

// Setup Elysia app
const app = new Elysia()
	.mount("/registry", handler)
	.post("/increment/:name", async () =>  = params;

		const counter = client.counter.getOrCreate(name);
		const newCount = await counter.increment(1);

		return ;
	})
	.listen(8080);

console.log("Server running at http://localhost:8080");
```

```sh }
npx tsx --watch server.ts
```

```sh }
bun --watch server.ts
```

Your server is now running at `http://localhost:8080`

This code can run either in your frontend or within your backend:

```ts }
// Create typed client
const client = createClient("http://localhost:8080");

// Use the counter actor directly
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions
const count = await counter.increment(3);
console.log("New count:", count);

// Get current state
const currentCount = await counter.getCount();
console.log("Current count:", currentCount);

// Listen to real-time events
const connection = counter.connect();
connection.on("countChanged", (newCount) => );

// Increment through connection
await connection.increment(1);
```

See the [JavaScript client documentation](/docs/clients/javascript) for more information.

```tsx }
const  = createRivetKit("http://localhost:8080");

function Counter() );

	counter.useEvent("newCount", (x: number) => setCount(x));

	const increment = async () => ;

	return (
		
			Count: 
			Increment
		
	);
}
```

See the [React documentation](/docs/clients/react) for more information.

```rust }
use rivetkit_client::;
use serde_json::json;

#[tokio::main]
async fn main() -> Result> ", count);
    }).await;
    
    // Call increment action
    let result = counter.action("increment", vec![json!(1)]).await?;
    println!("New count: ", result);
    
    Ok(())
}
```

See the [Rust client documentation](/docs/clients/rust) for more information.
## Cloudflare Workers Quickstart

# Cloudflare Workers Quickstart

Get started with Rivet Actors on Cloudflare Workers with Durable Objects

```sh
npm install rivetkit @rivetkit/cloudflare-workers
```

Create a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
	},
});

const registry = setup(,
});
```

Choose your preferred web framework:

```ts }
const app = new Hono } }>();

app.post("/increment/:name", async (c) => );
});

const  = createHandler(registry, );
;
```

```ts }
const  = createHandler(registry, ), ,
			});
		}

		return new Response("Not Found", );
	}
});

;
```

The `/rivet` endpoint is automatically mounted by Rivet and is required for client communication. The Cloudflare Workers driver handles this automatically. This can be configured with `managerPath`.

Configure your `wrangler.json` for Cloudflare Workers:

```json }

  ],
  "durable_objects": 
    ]
  },
  "kv_namespaces": [
    
  ]
}
```

Start the development server:

```sh
wrangler dev
```

Your server is now running at `http://localhost:8787`

Test your counter actor using HTTP requests:

```ts }
// Increment counter
const response = await fetch("http://localhost:8787/increment/my-counter", );

const result = await response.json();
console.log("Count:", result.count); // 1
```

```sh curl
# Increment counter
curl -X POST http://localhost:8787/increment/my-counter
```

Deploy to Cloudflare's global edge network:

```bash
wrangler deploy
```

Your actors will now run on Cloudflare's edge with persistent state backed by Durable Objects.

See the [Cloudflare Workers deployment guide](/docs/deploy/cloudflare-workers) for detailed deployment instructions and configuration options.

## Configuration Options

### Connect Frontend To The Rivet Actor

Create a type-safe client to connect from your frontend:

```ts }
// Create typed client (use your deployed URL)
const client = createClient("https://your-app.workers.dev/rivet");

// Use the counter actor directly
const counter = client.counter.getOrCreate(["my-counter"]);

// Call actions
const count = await counter.increment(3);
console.log("New count:", count);

// Get current state
const currentCount = await counter.getCount();
console.log("Current count:", currentCount);

// Listen to real-time events
const connection = counter.connect();
connection.on("countChanged", (newCount) => );

// Increment through connection
await connection.increment(1);
```

See the [JavaScript client documentation](/docs/clients/javascript) for more information.

```tsx }
const  = createRivetKit("https://your-app.workers.dev/rivet");

function Counter() );

	counter.useEvent("newCount", (x: number) => setCount(x));

	const increment = async () => ;

	return (
		
			Count: 
			Increment
		
	);
}
```

See the [React documentation](/docs/clients/react) for more information.

```rust }
use rivetkit_client::;
use serde_json::json;

#[tokio::main]
async fn main() -> Result> ", count);
    }).await;

    // Call increment action
    let result = counter.action("increment", vec![json!(1)]).await?;
    println!("New count: ", result);

    Ok(())
}
```

See the [Rust client documentation](/docs/clients/rust) for more information.

	Cloudflare Workers mounts the Rivet endpoint on `/rivet` by default.
## Quickstart

# Quickstart

  Set up actors with Node.js, Bun, and web frameworks

  Build real-time React applications with actors

  Build server-rendered Next.js experiences backed by actors

  Deploy actors on Cloudflare Workers with zero infrastructure
## Next.js Quickstart

# Next.js Quickstart

Get started with Rivet Actors in Next.js

```sh
npx create-next-app@latest my-app
cd my-app
```

Create a file at `src/rivet/registry.ts` with a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
	},
});

const registry = setup(,
});
```

Create a file at `src/app/api/rivet/[...all]/route.ts` to setup the API routes:

```ts }
const maxDuration = 300;

const  = toNextHandler(registry);
```

Create a file at `src/components/Counter.tsx` to use the actor in a component:

```tsx }
"use client";

const  = createRivetKit(
	process.env.NEXT_RIVET_ENDPOINT ?? "http://localhost:3000/api/rivet",
);

function Counter() );

	counter.useEvent("newCount", (x: number) => setCount(x));

	const increment = async () => ;

	return (
		
			Count: 
			Increment
		
	);
}
```

Import the `Counter` component in your page or layout to use it.

For more examples on connecting to your actors using React, check the [React documentation for RivetKit](/docs/clients/react).

See the [Vercel deployment guide](/docs/deploy/vercel) for detailed instructions on deploying your RivetKit app to Vercel.

## API Reference

For detailed information about the Next.js client API, see the [React Client API Reference](/docs/clients/react).
## React Quickstart

# React Quickstart

Build real-time React applications with Rivet Actors

```sh
npm install rivetkit @rivetkit/react
```

Create your actor registry on the backend:

```ts }
const counter = actor(,
	actions: ,
	},
});

const registry = setup(,
});
```

Start a server to run your actors:

```ts }
// Run server with default configuration
registry.start();
```

Set up your React application:

```tsx }
const client = createClient();
const  = createRivetKit(client);

function App() );

	counter.useEvent("newCount", (x: number) => setCount(x));

	const increment = async () => ;

	return (
		
			Rivet Counter
			Count: 

					Counter Name:
					 setCounterName(e.target.value)}
						style=}
					/>

			Increment

				Connection Status: 
				Try opening multiple tabs to see real-time sync.

	);
}

default App;
```

Configure Vite for development:

```ts }
default defineConfig(,
})
```

Start both the backend and frontend:

**Terminal 1**: Start the backend

```sh Backend
npx tsx --watch backend/server.ts
```

**Terminal 2**: Start the frontend

```sh Frontend  
npx vite
```

Open `http://localhost:5173` in your browser. Try opening multiple tabs to see real-time sync in action.

## Configuration Options

### Add Your Own Backend Endpoints

Add custom HTTP endpoints alongside your actors to handle additional business logic, authentication, and integrations with external services.

See [backend quickstart](/docs/actors/quickstart/backend) for more information.

## API Reference

For detailed information about the React client API, see the [React Client API Reference](/docs/clients/react).
## Scaling & Concurrency

# Scaling & Concurrency

This document covers how actors are able to scale better than traditional applications & provides tips on architecting your actors.

## How actors scale

Actors scale by design through these key properties:

| Property                             | Description                                                                                                                                                                                                                                                                                     |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Independent State**                | Each actor manages its own private data separately from other actors, so they never conflict with each other when running at the same time (i.e. using locking mechanisms).                                                                                                                     |
| **Action- & Event-Based Communication** | Actors communicate through asynchronous [actions](/docs/actors/actions) or [events](/docs/actors/events), making it easy to distribute them across different machines.                                                                                                                                               |
| **Location Transparency**            | Unlike traditional servers, actors don't need to know which machine other actors are running on in order to communicate with each other. They can run on the same machine, across a network, and across the world. Actors handle the network routing for you under the hood.                    |
| **Horizontal Scaling**               | Actors distribute workload by splitting responsibilities into small, focused units. Since each actor handles a limited scope (like a single user, document, or chat room), the system automatically spreads load across many independent actors rather than concentrating it in a single place. |

## Tips for architecting actors for scale

Here are key principles for architecting your actor system:

**Single Responsibility**

- Each actor should represent one specific entity or concept from your application (e.g., `User`, `Document`, `ChatRoom`).
- This makes your system scale better, since actors have small scopes and do not conflict with each other.

**State Management**

- Each actor owns and manages only its own state
- Use [actions](/docs/actors/actions) to request data from other actors
- Keep state minimal and relevant to the actor's core responsibility

**Granularity Guidelines**

- Too coarse: Actors handling too many responsibilities become bottlenecks
- Too fine: Excessive actors create unnecessary communication overhead
- Aim for actors that can operate independently with minimal cross-actor communication

### Examples

**Good actor boundaries**

- `User`: Manages user profile, preferences, and authentication
- `Document`: Handles document content, metadata, and versioning
- `ChatRoom`: Manages participants and message history

**Poor actor boundaries**

- `Application`: Too broad, handles everything
- `DocumentWordCount`: Too granular, should be part of DocumentActor
## Schedule

# Schedule

Scheduling is used to trigger events in the future. The actor scheduler is like `setTimeout`, except the timeout will persist even if the actor restarts, upgrades, or crashes.

	Scheduling is supported on the Rivet Cloud, Cloudflare Workers, file system, and memory drivers.

	Follow [this issue](https://github.com/rivet-dev/rivetkit/issues/1095) for Redis support.

## Use Cases

Scheduling is helpful for long-running timeouts like month-long billing periods or account trials.

## Scheduling

### `c.schedule.after(duration, actionName, ...args)`

Schedules a function to be executed after a specified duration. This function persists across actor restarts, upgrades, or crashes.

Parameters:

- `duration` (number): The delay in milliseconds.
- `actionName` (string): The name of the action to be executed.
- `...args` (unknown[]): Additional arguments to pass to the function.

### `c.schedule.at(timestamp, actionName, ...args)`

Schedules a function to be executed at a specific timestamp. This function persists across actor restarts, upgrades, or crashes.

Parameters:

- `timestamp` (number): The exact time in milliseconds since the Unix epoch when the function should be executed.
- `actionName` (string): The name of the action to be executed.
- `...args` (unknown[]): Additional arguments to pass to the function.

## Full Example

```typescript
const reminderService = actor(
  },
  
  actions: ;
      
      // Schedule the sendReminder action to run after the delay
      c.schedule.after(delayMs, "sendReminder", reminderId);
      
      return ;
    },
    
    sendReminder: (c, reminderId) => );
        });
      } else 
      
      // Clean up the processed reminder
      delete c.state.reminders[reminderId];
    }
  }
});
```
## Sharing and Joining State

# Sharing and Joining State

Actors store data separately by design, so combining data from multiple actors works differently than traditional databases. This pattern is similar to patterns you'll see in distributed like Cassandra, DynamoDB, and ClickHouse.

Here are your options based on your needs:

## Few actors, need latest data

- Call actions on each actor to get their data
- Actions are fast, so this works well for small numbers of actors
- Trade-off: More work when reading data, but writing is simple

## Many actors, need latest data

- Have actors automatically send updates to other actors that need them
- This keeps everyone in sync without extra calls
- Trade-off: More work when data changes, but reading is fast

## Many actors, okay with slightly old data

- Write data to a separate OLAP database like ClickHouse when updating state
- Query the analytics database for fast joins
- Trade-off: Extra database to maintain, but great performance

## Many actors, need latest data (not recommended)

- Write data to a transactional OLTP database like Postgres or MySQL when updating state
- This works but adds complexity you usually don't need
- Trade-off: Heavy database overhead for minimal benefit
## State

# State

Actor state provides the best of both worlds: it's stored in-memory and persisted automatically. This lets you work with the data without added latency while still being able to survive crashes & upgrades.

Actors can also be used with external SQL databases. This can be useful to integrate actors with existing
applications or for storing relational data. Read more [here](/docs/actors/external-sql).

## Initializing State

There are two ways to define an actor's initial state:

Define an actor state as a constant value:

```typescript
// Simple state with a constant
const counter = actor(,
  
  actions: 
});
```

This value will be cloned for every new actor using `structuredClone`.

Create actor state dynamically on each actors' creation:

```typescript
// State with initialization logic
const counter = actor(;
  },
  
  actions: 
});
```

To accept a custom input parameters for the initial state, use:

```typescript
interface CounterInput 

// State with initialization logic
const counter = actor(;
  },
  
  actions: 
});
```

Read more about [input parameters](/docs/actors/input) here.

If accepting arguments to `createState`, you **must** define the types: `createSTate(c: ActorInitContext, input: MyType)`

Otherwise, the return type will not be inferred and `c.vars` will be of type `unknown`.

The `createState` function is called once when the actor is first created. See [Lifecycle](/docs/actors/lifecycle) for more details.

## Modifying State

To update state, modify the `state` property on the context object (`c.state`) in your actions:

```typescript
const counter = actor(,
  
  actions: ,
    
    add: (c, value) => 
  }
});
```

Only state stored in the `state` object will be persisted. Any other variables or properties outside of this are not persisted.

## State Saves

Actors automatically handle persisting state transparently. This happens at the end of every action if the state has changed. State is also automatically saved after `onFetch` and `onWebSocket` handlers finish executing.

For `onWebSocket` handlers specifically, you'll need to manually save state using `c.saveState()` while the WebSocket connection is open if you want state changes to be persisted immediately. This is because WebSocket connections can remain open for extended periods, and state changes made during event handlers (like `message` events) won't be automatically saved until the connection closes.

In other cases where you need to force a state change mid-action, you can use `c.saveState()`. This should only be used if your action makes an important state change that needs to be persisted before the action completes.

```typescript
const criticalProcess = actor(,
  
  actions: `);
      
      // Force save state before the async operation
      c.saveState();
      
      // Long-running operation that might fail
      await someRiskyOperation();
      
      // Update state again
      c.state.steps.push(`Completed step $`);
      
      return c.state.currentStep;
    }
  }
});
```

## State Isolation

Each actor's state is completely isolated, meaning it cannot be accessed directly by other actors or clients.

To interact with an actor's state, you must use [Actions](/docs/actors/actions). Actions provide a controlled way to read from and write to the state.

If you need a shared state between multiple actors, see [sharing and joining state](/docs/actors/sharing-and-joining-state).

## Ephemeral Variables

In addition to persisted state, actors can store ephemeral data that is not saved to permanent storage using `vars`. This is useful for temporary data or non-serializable objects like database connections or event emitters.

For complete documentation on ephemeral variables, see [Ephemeral Variables](/docs/actors/ephemeral-variables).

## Type Limitations

State is currently constrained to the following types:

- `null`
- `undefined`
- `boolean`
- `string`
- `number`
- `BigInt`
- `Date`
- `RegExp`
- `Error`
- Typed arrays (`Uint8Array`, `Int8Array`, `Float32Array`, etc.)
- `Map`
- `Set`
- `Array`
- Plain objects
## Testing

# Testing

Rivet provides a straightforward testing framework to build reliable and maintainable applications. This guide covers how to write effective tests for your actor-based services.

## Setup

To set up testing with Rivet:

```bash
# Install Vitest
npm install -D vitest

# Run tests
npm test
```

## Basic Testing Setup

Rivet includes a test helper called `setupTest` that configures a test environment with in-memory drivers for your actors. This allows for fast, isolated tests without external dependencies.

```ts tests/my-actor.test.ts
test("my actor test", async (test) =>  = await setupTest(test, app);
  
  // Now you can interact with your actor through the client
  const myActor = await client.myActor.get();
  
  // Test your actor's functionality
  await myActor.someAction();
  
  // Make assertions
  const result = await myActor.getState();
  expect(result).toEqual("updated");
});
```

```ts src/index.ts
const myActor = actor(,
  actions: ,
    getState: (c) => 
  }
});

const registry = setup(
});
```

## Testing Actor State

The test framework uses in-memory drivers that persist state within each test, allowing you to verify that your actor correctly maintains state between operations.

```ts tests/counter.test.ts
test("actor should persist state", async (test) =>  = await setupTest(test, app);
  const counter = await client.counter.get();
  
  // Initial state
  expect(await counter.getCount()).toBe(0);
  
  // Modify state
  await counter.increment();
  
  // Verify state was updated
  expect(await counter.getCount()).toBe(1);
});
```

```ts src/index.ts
const counter = actor(,
  actions: ,
    getCount: (c) => 
  }
});

const registry = setup(
});
```

## Testing Events

For actors that emit events, you can verify events are correctly triggered by subscribing to them:

```ts tests/chat-room.test.ts
test("actor should emit events", async (test) =>  = await setupTest(test, app);
  const chatRoom = await client.chatRoom.get();
  
  // Set up event handler with a mock function
  const mockHandler = vi.fn();
  chatRoom.on("newMessage", mockHandler);
  
  // Trigger the event
  await chatRoom.sendMessage("testUser", "Hello world");
  
  // Wait for the event to be emitted
  await vi.waitFor(() => );
});
```

```ts src/index.ts
const chatRoom = actor(,
  actions: );
      c.broadcast("newMessage", username, message);
    },
    getHistory: (c) => ,
  },
});

// Create and the app
const registry = setup(
});
```

## Testing Schedules

Rivet's schedule functionality can be tested using Vitest's time manipulation utilities:

```ts tests/scheduler.test.ts
test("scheduled tasks should execute", async (test) =>  = await setupTest(test, app);
  const scheduler = await client.scheduler.get();
  
  // Set up a scheduled task
  await scheduler.scheduleTask("reminder", 60000); // 1 minute in the future
  
  // Fast-forward time by 1 minute
  await vi.advanceTimersByTimeAsync(60000);
  
  // Verify the scheduled task executed
  expect(await scheduler.getCompletedTasks()).toContain("reminder");
});
```

```ts src/index.ts
const scheduler = actor(,
  actions: ;
    },
    completeTask: (c, taskName: string) => ;
    },
    getCompletedTasks: (c) => 
  }
});

const registry = setup(
});
```

The `setupTest` function automatically calls `vi.useFakeTimers()`, allowing you to control time in your tests with functions like `vi.advanceTimersByTimeAsync()`. This makes it possible to test scheduled operations without waiting for real time to pass.

## Best Practices

1. **Isolate tests**: Each test should run independently, avoiding shared state.
2. **Test edge cases**: Verify how your actor handles invalid inputs, concurrent operations, and error conditions.
3. **Mock time**: Use Vitest's timer mocks for testing scheduled operations.
4. **Use realistic data**: Test with data that resembles production scenarios.

Rivet's testing framework automatically handles server setup and teardown, so you can focus on writing effective tests for your business logic.
## Node.js & Bun

# Node.js & Bun

The Rivet JavaScript client allows you to connect to and interact with actors from browser and Node.js applications.

## Getting Started

See the [backend quickstart guide](/docs/actors/quickstart/backend) for getting started.

## API Reference

See the [RivetKit client API](http://rivet.dev/docs/actors/clients/#actor-client).
## Next.js

# Next.js

The Rivet Next.js client allows you to connect to and interact with actors in Next.js applications.

	Check out the complete example

	Use Next.js API routes to run RivetKit Registry

## Getting Started

See the [Next.js quickstart guide](/docs/actors/quickstart/next-js) for getting started.

## API Reference

It's the same as the [React client API reference](https://rivet.dev/docs/clients/react#api-reference), since the RivetKit React package is used in both Next.js and React applications.
## OpenAPI

# OpenAPI

The Rivet OpenAPI spec is available [here](https://github.com/rivet-dev/rivetkit/blob/main/clients/openapi/openapi.json)

The OpenAPI spec currently only exposes creating & managing actors. It does not expose how to communicate with actors. See the [HTTP client implementation](https://github.com/rivet-dev/rivetkit/blob/b5072fdac18d90a27bb6cd36e9ee73b00d36d42c/packages/rivetkit/src/client/actor-handle.ts) for reference.
## React

# React

Learn how to create real-time, stateful React applications with Rivet's actor model. The React integration provides intuitive hooks for managing actor connections and real-time updates.

## Getting Started

See the [React quickstart guide](/docs/actors/quickstart/react) for getting started.

## API Reference

### `createRivetKit(client, options?)`

Creates the Rivet hooks for React integration.

```tsx
const client = createClient();
const  = createRivetKit(client);
```

#### Parameters

- `client`: The Rivet client created with `createClient`
- `options`: Optional configuration object

#### Returns

An object containing:
- `useActor`: Hook for connecting to actors

### `useActor(options)`

Hook that connects to an actor and manages the connection lifecycle.

```tsx
const actor = useActor(,
  enabled: true
});
```

#### Parameters

- `options`: Object containing:
  - `name`: The name of the actor type (string)
  - `key`: Array of strings identifying the specific actor instance
  - `params`: Optional parameters passed to the actor connection
  - `createWithInput`: Optional input to pass to the actor on creation
  - `createInRegion`: Optional region to create the actor in if does not exist
  - `enabled`: Optional boolean to conditionally enable/disable the connection (default: true)

#### Returns

Actor object with the following properties:
- `connection`: The actor connection for calling actions, or `null` if not connected
- `isConnected`: Boolean indicating if the actor is connected
- `state`: Current actor state (if available)
- `useEvent(eventName, handler)`: Method to subscribe to actor events

### `actor.useEvent(eventName, handler)`

Subscribe to events emitted by the actor.

```tsx
const actor = useActor();

actor.useEvent("newCount", (count: number) => );
```

#### Parameters

- `eventName`: The name of the event to listen for (string)
- `handler`: Function called when the event is emitted

#### Lifecycle

The event subscription is automatically managed:
- Subscribes when the actor connects
- Cleans up when the component unmounts or actor disconnects
- Re-subscribes on reconnection

## Advanced Patterns

### Multiple Actors

Connect to multiple actors in a single component:

```tsx
function Dashboard() );
  
  const notifications = useActor();

  userProfile.useEvent("profileUpdated", (profile) => );

  notifications.useEvent("newNotification", (notification) => );

  return (

  );
}
```

### Conditional Connections

Control when actors connect using the `enabled` option:

```tsx
function ConditionalActor() );

  return (
    
       setEnabled(!enabled)}>

      )}
    
  );
}
```

### Real-time Collaboration

Build collaborative features with multiple event listeners:

```tsx
function CollaborativeEditor() );
  
  const document = useActor(
  });

  // Listen for content changes
  document.useEvent("contentChanged", (newContent) => );

  // Listen for cursor movements
  document.useEvent("cursorMoved", () => ));
  });

  // Listen for user join/leave
  document.useEvent("userJoined", () =>  joined the document`);
  });

  document.useEvent("userLeft", () =>  = prev;
      return rest;
    });
  });

  const updateContent = async (newContent: string) => ;

  return (

  );
}
```

### Authentication

Connect authenticated actors in React:

```tsx
function AuthenticatedApp() ,
		enabled: !!authToken // Only connect when authenticated
	});

	const login = async () => ;

	if (!authToken) 

	return (
		
			Authenticated Counter

	);
}
```

Learn more about [authentication](/docs/actors/authentication).
## Rust

# Rust

The Rivet Rust client provides a way to connect to and interact with actors from Rust applications.

## Quickstart

    Add RivetKit client to your `Cargo.toml`:
    
    ```toml
    [dependencies]
    rivetkit-client = "0.1.0"
    ```

      Make sure you have a running Rivet actor server to connect to. You can follow the [Node.js & Bun Quickstart](https://rivet.dev/docs/actors/quickstart/backend/) to set up a simple actor server.

    ```rust src/main.rs
    use rivetkit_client::;
    use serde_json::json;

    #[tokio::main]
    async fn main() -> anyhow::Result : ", username, message);
        }).await;

        // Send message to room
        chat_room.action("sendMessage", vec![
            json!("william"),
            json!("All the world's a stage.")
        ]).await?;

        // When finished
        client.disconnect();

        Ok(())
    }
    ```

    In a separate terminal, run your client code:
    
    ```sh
    cargo run
    ```

    Run it again to see the state update.

## API Reference

For detailed API documentation, please refer to the [RivetKit Rust client implementation](https://github.com/rivet-dev/rivetkit/blob/main/clients/rust).
## Deploying to AWS ECS

# Deploying to AWS ECS

Run your backend on Amazon ECS with Fargate using a simple container image and service definition.

## Guide

- AWS account with permissions for ECS, ECR, and IAM
- AWS CLI v2 configured (`aws configure`)
- An existing VPC with private subnets and security groups for ECS
- Container registry (ECR) and your backend repository

Navigate to Rivet and click _Connect > Manual_. Copy the environment variables provided, they will be used in the task definition. They should look something like this:

```bash
RIVET_API_ENDPOINT=https://api-us-west-1.rivet.dev
RIVET_NAMESPACE=your-namespace-id
RIVET_TOKEN=your-token
```

Create a `Dockerfile` in your project root:

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY . .
ENV PORT=8080
CMD ["node", "server.js"]
```

Authenticate to ECR, build the image, and push it. Replace the AWS account, region, and repository names with your own.

```bash
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 123456789012.dkr.ecr.us-east-1.amazonaws.com
docker build -t backend:latest .
docker tag backend:latest 123456789012.dkr.ecr.us-east-1.amazonaws.com/backend:latest
docker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/backend:latest
```

Create `backend-task.json` describing the ECS task. Update the ARNs, subnets, and security groups for your environment.

```json
,
        ,
        
      ]
    }
  ]
}
```

You do not need to expose a container port. Rivet tunnels traffic directly to your backend.

Register the task definition:

```bash
aws ecs register-task-definition --cli-input-json file://backend-task.json
```

Create or reuse an ECS cluster, then launch a service with the new task definition. Substitute your subnet and security group IDs.

```bash
aws ecs create-cluster --cluster-name backend
aws ecs create-service \
  --cluster backend \
  --service-name backend \
  --task-definition backend \
  --desired-count 1 \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration="
```

Check that the task is running:

```bash
aws ecs describe-services --cluster backend --services backend --query "services[0].deployments"
```

Your runner should appear as connected on the Rivet dashboard once the task is healthy.
## Deploy To Amazon Web Services Lambda

# Deploy To Amazon Web Services Lambda

_AWS Lambda is coming soon_
## Deploying to Cloudflare Workers

# Deploying to Cloudflare Workers

Deploy your Cloudflare Workers + RivetKit app to [Cloudflare Workers](https://workers.cloudflare.com/).

Complete example Cloudflare Workers + RivetKit app.

## Guide

- [Cloudflare account](https://dash.cloudflare.com/) with Durable Objects enabled
- [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/install-and-update/) v3
- Access to the [Rivet Cloud](https://dashboard.rivet.dev/) or a self-hosted [Rivet Engine](/docs/general/self-hosting)
- A Cloudflare Worker app integrated with RivetKit
  - See the [Cloudflare Workers quickstart](/docs/actors/quickstart/cloudflare-workers/) or [Cloudflare Workers example](https://github.com/rivet-dev/rivetkit/tree/main/examples/cloudflare-workers) to get started

Your project should have the following files:

- `src/index.ts` (or similar entry point with `createHandler`)
- `src/registry.ts` (or similar actor registry file)
- `wrangler.json` with proper Durable Objects and KV namespace configuration

If your project is not integrated with RivetKit yet, follow the [Cloudflare Workers quickstart guide](/docs/actors/quickstart/cloudflare-workers/) or see the [Cloudflare Workers example](https://github.com/rivet-dev/rivetkit/tree/main/examples/cloudflare-workers).

Deploy to Cloudflare's global network:

```sh
wrangler deploy
```

Your worker will be deployed and you'll receive a URL like `https://my-rivetkit-worker.workers.dev`.

More information on deployments is available in [Cloudflare's docs](https://developers.cloudflare.com/workers/wrangler/commands/#deploy).

After running `wrangler deploy`, note the URL printed in the output (e.g., `https://my-rivetkit-worker.workers.dev`).

Your RivetKit endpoint will be available at this URL with `/rivet` appended:
- Example: `https://my-rivetkit-worker.workers.dev/rivet`

Use this endpoint URL when configuring your RivetKit client or connecting from the Rivet dashboard.

## Advanced

### Accessing Environment Bindings

You can access Cloudflare Workers environment bindings directly using the importable `env`:

```typescript
// Access environment variables and secrets in top-level scope
const API_KEY = env.API_KEY;
const LOG_LEVEL = env.LOG_LEVEL || "info";

// Use bindings in your actor
const myActor = actor(,
  
  actions: 
    }
  }
});
```

### Driver Context

The Cloudflare Workers driver provides access to the Durable Object state and environment through the driver context in `createVars`.

```typescript
const myActor = actor(,
  
  // Save the Cloudflare driver context
  createVars: (ctx: ActorInitContext, driver: DriverContext) => (),
  
  actions: ,
  }
});
```

The Cloudflare Workers driver context type is exported as `DriverContext` from `@rivetkit/cloudflare-workers`:

```typescript
interface DriverContext 
```

While you have access to the Durable Object state, be cautious when directly modifying KV storage or alarms, as this may interfere with RivetKit's internal operations and potentially break actor functionality.
## Deploying to Freestyle

# Deploying to Freestyle

Deploy RivetKit app to [Freestyle.sh](https://freestyle.sh/), a cloud platform for running AI-generated code with built-in security and scalability.

Freestyle provides built-in security for running untrusted AI-generated code, making it ideal for AI agent applications. Using Rivet, it is easy to deploy your vibe-coded or user-provided RivetKit backends straight to Freestyle.

Complete example of deploying RivetKit app to Freestyle.sh.

## Setup

Install RivetKit and Hono and create your registry:

```bash
npm install rivetkit hono
```

Update your server code to run the registry serverless with Deno.

```typescript }
const  = registry.start(/api`,
});

// Freestyle uses Deno under the hood for web deployments
// @ts-ignore
Deno.serve(fetch);
```

Deploy your application to Freestyle with the correct configuration. Create a deployment script or add this to your existing deployment process:

```typescript
const FREESTYLE_DOMAIN = "my-domain.style.dev"; // Change to your desired Freestyle domain

const res = await freestyle.deployWeb(buildDir, `,
		RIVET_RUNNER_KIND: "serverless",
		// For self-hosted instances:
		// RIVET_ENDPOINT: "http://127.0.0.1:6420",
		RIVET_ENDPOINT: "api.rivet.dev",
	},
	timeout: 60 * 5, // Increases max request lifetime on the runner
	entrypoint: "server.ts", // File which starts serverless runner
	domains: [FREESTYLE_DOMAIN],
	build: false,
});
```

Details on `buildDir` and other settings are available on [Freestyle docs](https://docs.freestyle.sh/web/web).

Run this deployment script to push your application to Freestyle.

**Deployment Configuration:**

- `timeout: 60 * 5` - Set timeout to 5 minutes for actor operations - it's important to keep this high
- `entrypoint: "server.ts"` - Entry point file with your serverless setup
- `domains` - Your Freestyle domain(s)
- `build: false` - Disable build if you're pre-building your assets

Update the runner configuration on the Rivet side to connect with your Freestyle deployment. Create a configuration script and run it after your Freestyle deployment is live:

```typescript
const rivet = new RivetClient();

const FREESTYLE_DOMAIN = "my-domain.style.dev"; // Change to your desired Freestyle domain
const RIVET_NAMESPACE = "my-rivet-namespace"; // Change to your Rivet namespace

await rivet.runnerConfigs.upsert("freestyle-runner", /start`,
		runnersMargin: 1,
		minRunners: 1,
		maxRunners: 1,
		slotsPerRunner: 1,
		// Must be shorter than Freestyle request `timeout` config
		requestLifespan: 60 * 5 - 5,
	},
	namespace: RIVET_NAMESPACE,
});
```

Execute this configuration script to register your Freestyle deployment with Rivet.

**Runner Configuration:**

- `url` - Freestyle deployment URL with `/start` endpoint
- `runnersMargin` - Buffer of runners to maintain
- `minRunners/maxRunners` - Scaling limits
- `slotsPerRunner` - Concurrent actors per runner
- `requestLifespan` - Request timeout (slightly less than Freestyle timeout)

Once executed, Rivet will be connected to your Freestyle serverless instance.
## Deploying to Google Cloud Run

# Deploying to Google Cloud Run

Run your backend on Cloud Run with a lightweight container image and one command deploy.

## Guide

- Google Cloud project with Cloud Run and Artifact Registry enabled
- `gcloud` CLI authenticated (`gcloud auth login`) and project set (`gcloud config set project YOUR_PROJECT`)
- Artifact Registry repository or Container Registry enabled
- Your backend application repository

Navigate to Rivet and click _Connect > Manual_. Copy the environment variables provided, they will be used when deploying. They should look something like this:

```bash
RIVET_API_ENDPOINT=https://api-us-west-1.rivet.dev
RIVET_NAMESPACE=your-namespace-id
RIVET_TOKEN=your-token
```

Create a `Dockerfile` in your project root:

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY . .
ENV PORT=8080
CMD ["node", "server.js"]
```

Use Cloud Build to build and push the image. Replace the region and repository with your own.

```bash
gcloud builds submit --tag us-central1-docker.pkg.dev/YOUR_PROJECT/backend/backend:latest
```

Deploy the service to Cloud Run, passing the Rivet environment variables. Adjust the region, image, and VPC connector settings as needed.

```bash
gcloud run deploy backend \
  --image us-central1-docker.pkg.dev/YOUR_PROJECT/backend/backend:latest \
  --region us-central1 \
  --allow-unauthenticated \
  --min-instances 1 \
  --set-env-vars RIVET_API_ENDPOINT=https://api-us-west-1.rivet.dev,RIVET_NAMESPACE=your-namespace-id,RIVET_TOKEN=your-token
```

You do not need to expose a container port. Rivet tunnels traffic directly to your backend.

Confirm the service is running:

```bash
gcloud run services describe backend --region us-central1 --format 'value(status.conditions[?type="Ready"].status)'
```

Your runner should appear as connected on the Rivet dashboard once the service reports ready.
## Deploying to Hetzner

# Deploying to Hetzner

Please see the [VM & Bare Metal](/docs/deploy/vm-and-bare-metal) guide.
## Deploying to Kubernetes

# Deploying to Kubernetes
#
Run your backend on any Kubernetes cluster with a simple container image and deployment manifest.

## Guide

- A Kubernetes cluster with `kubectl` access (AKS, EKS, GKE, k3s, etc.)
- Container registry credentials (Docker Hub, GHCR, GCR, etc.)
- Your backend application repository

Navigate to Rivet and click _Connect > Manual_. Copy the environment variables provided, they will be used in later manifests. They should look something like this:

```bash
RIVET_API_ENDPOINT=https://api-us-west-1.rivet.dev
RIVET_NAMESPACE=your-namespace-id
RIVET_TOKEN=your-token
```

Create a `Dockerfile` in your project root:

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --omit=dev
COPY . .
ENV PORT=8080
CMD ["node", "server.js"]
```

```bash
docker build -t registry.example.com/your-team/backend:latest .
docker push registry.example.com/your-team/backend:latest
```

Replace `registry.example.com/your-team` with your registry path. Auth with `docker login` first if needed.

Create a `backend-secrets.yaml` for your environment variables:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: backend-secrets
type: Opaque
stringData:
  RIVET_API_ENDPOINT: https://api-us-west-1.rivet.dev
  RIVET_NAMESPACE: your-namespace-id
  RIVET_TOKEN: your-token
```

Then create a `deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: backend
          image: registry.example.com/your-team/backend:latest
          envFrom:
            - secretRef:
                name: backend-secrets
```

You do not need to expose a container port. Rivet tunnels traffic directly to your backend.

Apply both manifests:

```bash
kubectl apply -f backend-secrets.yaml
kubectl apply -f deployment.yaml
```

Add a `Service` or Ingress if you need external access.

Check that the pod is running:

```bash
kubectl get pods -l app=backend
```

Your runner should appear as connected on the Rivet dashboard once the pod is ready.
## Deploying to Railway

# Deploying to Railway
#
Deploy your RivetKit app to [Railway](https://railway.app).

## Option A: Deploy from Template

If you're starting from scratch, go to the Connect tab on the Rivet dashboard and follow the Railway deployment steps. This give you a 1-click deploy of the [RivetKit Railway template]().

## Option B: Deploy Manual

- [Railway account](https://railway.app)
- Your RivetKit app
  - If you don't have one, see the [Quickstart](/docs/actors/quickstart) page or our [Examples](https://github.com/rivet-dev/rivetkit/tree/main/examples)
- Access to the [Rivet Cloud](https://dashboard.rivet.dev/) or a [self-hosted Rivet Engine](/docs/general/self-hosting)

Ensure your `package.json` has a start script:

```json

  // ... Rest of package.json
}
```

1. Connect your GitHub account to Railway
2. Select your repository containing your RivetKit app
3. Railway will automatically detect and deploy your app

Railway will automatically deploy your RivetKit app on every git push.

Detailed steps are available on [Railway's docs](https://docs.railway.com/quick-start).

You do not need to expose a container port. Rivet tunnels traffic directly to your backend.

After selecting your project on the Rivet dashboard, go to Connect > Railway to get the environment variables needed.

To add your environment variables:
1. Go to your Railway project dashboard
2. Select your service
3. Navigate to the **Variables** tab
4. Add the required environment variables and deploy your changes

Detailed steps are available on [Railway's docs](https://docs.railway.com/guides/variables#service-variables).

You should see your runner connected on the Connect tab of your Rivet Dashboard. Now you can create and connect to your Rivet Actors.
## Supabase

# Supabase

_Supabase is coming soon_
## Deploying to Vercel

# Deploying to Vercel

Deploy your Next.js + RivetKit app to [Vercel](https://vercel.com/).

Complete example Next.js + RivetKit app.

## Guide

- [Vercel account](https://vercel.com/)
- Access to the [Rivet Cloud](https://dashboard.rivet.dev/) or a self-hosted [Rivet Engine](/docs/general/self-hosting)
- A Next.js app integrated with RivetKit
  - See the [Next.js quickstart](/docs/actors/quickstart/next-js/) or [Next.js example](https://github.com/rivet-dev/rivetkit/tree/main/examples/next-js) to get started
  - Your project should have the following files:
    - `src/app/api/rivet/[...all]/route.ts`
    - `src/rivet/registry.ts`

1. Connect your GitHub project to Vercel
2. Select your repository containing your Next.js + RivetKit app
3. Vercel will deploy your app

More information on deployments are available in [Vercel's docs](https://vercel.com/docs/deployments).

1. Visit the [Rivet dashboard](https://dashboard.rivet.dev)
2. Navigate to _Connect > Vercel_
3. Skip to the _Deploy to Vercel_ step
4. Input your deployed Vercel site URL
	- e.g. `https://my-app.vercel.app/api/rivet`
5. Once it shows as successfully connected, click _Done_

Your Vercel Functions deployment is now connected to Rivet.
## Deploying to VMs & Bare Metal

# Deploying to VMs & Bare Metal

Run your backend on any Linux VM or bare metal host with a basic systemd unit.

## Guide

- Build your backend locally.
- Copy the build output to your server (example):

```bash
scp -r ./dist user@server:/opt/backend
```

Place the files somewhere readable by the service user, such as `/opt/backend`.

Navigate to Rivet and click _Connect > Manual_. Copy the environment variables provided, they will be used in the next step. They should look something like this:

```bash
RIVET_API_ENDPOINT=https://api-us-west-1.rivet.dev
RIVET_NAMESPACE=your-namespace-id
RIVET_TOKEN=your-token
```

Create `/etc/systemd/system/backend.service`:

```ini
[Unit]
Description=Backend Service
After=network.target

[Service]
Type=simple
WorkingDirectory=/opt/backend
ExecStart=/usr/bin/node server.js
Restart=on-failure
Environment=RIVET_API_ENDPOINT=https://api.rivet.dev
Environment=RIVET_NAMESPACE=your-namespace-id
Environment=RIVET_TOKEN=your-token

[Install]
WantedBy=multi-user.target
```

Replace the environment values with those from the Connect tab in the Rivet dashboard (or your self-hosted engine) and adjust paths to match your deployment.

Reload systemd units and start the service:

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now backend.service
```

## Operating

### Restart

Restart the service after deploying new builds or environment changes:

```bash
sudo systemctl restart backend.service
```

### Logs

Follow realtime logs when debugging:

```bash
sudo journalctl -u backend.service -f
```
## Build Your Own

# Build Your Own

Each driver implements common interfaces defined by RivetKit, including:

- **ActorDriver**: Manages actor state, lifecycle, and persistence
- **ManagerDriver**: Handles actor discovery, routing, and scaling

## Source Code Locations

Get started by looking at source code for the driver interfaces and existing drivers:

- **Driver Interfaces**
  - **ActorDriver*** [Source Code](https://github.com/rivet-dev/rivetkit/blob/main/packages/core/src/actor/driver.ts)
  - **ManagerDriver*** [Source Code](https://github.com/rivet-dev/rivetkit/blob/main/packages/core/src/manager/driver.ts)
- **Driver Implementations**: [Source Code](https://github.com/rivet-dev/rivetkit/tree/main/packages/core/src/drivers)
## File System

# File System

The File System driver is the default driver for Rivet Actors, providing local file-based storage for state management and inter-actor communication. If no driver is specified in your configuration, the File System driver will be used automatically.

The File System driver is ideal for development and single-node deployments. For production applications that need to scale horizontally across multiple machines, use the [Redis driver](/docs/drivers/redis).

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | No |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | Yes |

## Setup

The File System driver is included with `rivetkit` - no additional packages needed:

```bash
npm install rivetkit
```

Use the default configuration with automatic path based on your current working directory:

```typescript }
const driver = createFileSystemDriver();
const  = registry.start();

// ...rest of your server...
```

The default path is stored in your system's data path. The path is unique to the current working directory, so you can safely run multiple projects on the same machine.

Specify a custom path for actor storage:

```typescript }
const driver = createFileSystemDriver();
const  = registry.start();

// ...rest of your server...
```

**Configuration Options:**

- `path` - Custom directory path for storing actor data (optional)

## Data Management

The path where your actors are stored is printed when you start your project. To reset your actors, delete the folder that is printed.

If running on a single node, make sure to back up your actors folder regularly. `rsync` works nicely with this because each actor is stored as its own file.

## Examples

Basic File System driver setup and configuration example.
## Memory

# Memory

The Memory driver stores all actor state and communication in memory, making it ideal for testing, development, and prototyping scenarios where persistence is not required.

The Memory driver does not persist data between server restarts. For production applications that need to scale horizontally across multiple machines, see [self-hosting](/docs/self-hosting)

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | No |
| WebSockets | Yes |
| SSE | Yes |
| Edge | No |
| Scheduling | Yes |

## Setup

The Memory driver is included with `rivetkit` - no additional packages needed:

```bash
npm install rivetkit
```

Create and use the Memory driver:

```typescript }
const driver = createMemoryDriver();
const  = registry.start();

// ...rest of your server...
```

The Memory driver requires no configuration options.
## Code Autofill Example

# Code Autofill Example

This page demonstrates the code autofill feature with template variables.

## Basic Example

The following code snippet uses autofill to populate your project and namespace information. Click on any blue highlighted value to change your selection:

```ts }
const client = createClient(}",
  endpoint: "}"
});

console.log("Connected to project: }");
console.log("Using namespace: }");
```

## Using Default Values

You can specify default values that will be shown before the user selects a project. Format: `}`

```ts }
const client = createClient(}",
  endpoint: "}"
});

const config = }",
  namespace: "}",
};
```

## Multiple Template Variables

You can use various template variables in your code:

```ts }
const config = }",

  // Project info
  project: }",
    name: "}",
  },

  // Namespace info
  namespace: }",
    name: "}",
    token: "}",
  },

  // Connection
  engineUrl: "}",
};
```

## Regular Code Block (No Autofill)

This code block doesn't use autofill:

```ts
// This is a regular code block without autofill
const greeting = "Hello, World!";
console.log(greeting);
```
## Architecture

# Architecture

Rivet supports three topologies that define how actors are distributed and scale.

	Each platform configures a default topology appropriate for that environment. In most cases, you can rely on these defaults unless you have specific distribution needs.

## Configuration

```typescript
const config = ;
```

## Types of Topologies

### Standalone

- **How it works**: Runs all actors in a single process
- **When to use**: Development, testing, simple apps with low traffic
- **Limitations**: No horizontal scaling, single point of failure
- **Default on**: Node.js, Bun

### Partition

- **How it works**: Each actor has its own isolated process. Clients connect directly to the actor for optimal performance.
- **When to use**: Production environments needing horizontal scaling
- **Limitations**: Minimal - balanced performance and availability for most use cases
- **Default on**: Rivet, Cloudflare Workers

### Coordinate

- **How it works**: Creates a peer-to-peer network between multiple servers with leader election with multiple actors running on each server. Clients connect to any server and data is transmitted to the leader over a pubsub server.
- **When to use**: High-availability scenarios needing redundancy and failover
- **Limitations**: Added complexity, performance overhead, requires external data source
- **Default on**: _None_

## Choosing a Topology

In most cases, use your platform's default:

1. **Standalone**: Simple, great for development
2. **Partition**: Best scaling & cost for production
3. **Coordinate**: Good for specialized deployment scenarios
## Cross-Origin Resource Sharing

# Cross-Origin Resource Sharing

Cross-Origin Resource Sharing (CORS) is a security mechanism that allows a web application running at one origin to access resources from a different origin. Without CORS, browsers block cross-origin HTTP requests by default as a security measure.

You'll need to configure CORS when:

- **Local Development**: You're developing locally and your client runs on a different port than your actor service
- **Different Domain**: Your frontend application is hosted on a different domain than your actor service

## Registry-Level CORS

Configure CORS directly in your registry setup for applications that do not require configuring CORS on their own endpoints.

```typescript }
const  = registry.start(
});
```

### Configuration Options

#### `origin`

`string | string[] | (origin: string) => boolean | string`

Specifies which domains can access your resources:

```typescript }
// Single domain
origin: "https://example.com"

// Multiple domains
origin: ["https://app.com", "https://admin.com"]

// Dynamic validation
origin: (origin) => 

// All domains (not recommended for production)
origin: "*"
```

#### `allowMethods`

`string[]`

HTTP methods clients are allowed to use:

```typescript
allowMethods: ["GET", "POST", "OPTIONS"]  // Common for Rivet
```

#### `allowHeaders`

`string[]`

Headers that clients can send in requests:

```typescript
allowHeaders: [
  "Authorization",           // Your auth headers
  "Content-Type",           // Standard content type
  "X-API-Key",              // Custom API key header
  ...ALLOWED_PUBLIC_HEADERS // Required Rivet headers
]
```

#### `credentials`

`boolean`

Whether to allow credentials (cookies, auth headers):

```typescript
credentials: true  // Required for authentication
```

When `credentials: true`, you cannot use `origin: "*"`. Specify exact origins instead.

#### `maxAge`

`number`

How long browsers cache CORS preflight responses (in seconds):

```typescript
maxAge: 600  // Cache for 10 minutes
```

#### `exposeHeaders`

`string[]`

Server headers that browsers can access:

```typescript
exposeHeaders: ["Content-Length", "X-Request-Id"]
```

## Router-Level CORS

For applications that need to expose their own routes, configure CORS at the router level:

```typescript }
registry.start();

const app = new Hono();

app.use("*", cors());

serve(app);
```

```typescript }
registry.start();

const app = express();

app.use(cors());

app.use("/registry", handler);
app.listen(8080);
```

### Required Headers for Rivet

Rivet requires specific headers for communication. Always include `ALLOWED_PUBLIC_HEADERS`:

```typescript }
const corsConfig = ;
```

These are automatically configured if using `registry.start()`.

Without `ALLOWED_PUBLIC_HEADERS`, Rivet clients won't be able to communicate with your actors from the browser.

## Development vs Production

### Development Setup

For local development, allow localhost origins:

```typescript
const isDev = process.env.NODE_ENV !== "production";

const corsConfig = ;
```

### Production Setup

For production, be restrictive with origins:

```typescript
const corsConfig = ;
```

## Troubleshooting

### Common CORS Errors

**"Access to fetch blocked by CORS policy"**
- Add your frontend's origin to the `origin` list
- Ensure `ALLOWED_PUBLIC_HEADERS` are included in `allowHeaders`

**"Request header not allowed"**
- Add the missing header to `allowHeaders` 
- Include `ALLOWED_PUBLIC_HEADERS` in your configuration

**"Credentials mode mismatch"**
- Set `credentials: true` in CORS config
- Cannot use `origin: "*"` with credentials
## Documentation for LLMs & AI

# Documentation for LLMs & AI

Rivet provides optimized documentation formats specifically designed for Large Language Models (LLMs) and AI integration tools.

## Available Formats

### `llms.txt` (Condensed)
A condensed version of the documentation perfect for quick reference and context-aware AI assistance.

**Access:** /llms.txt

This format includes:
- Key concepts and features
- Essential getting started information
- Summaries of main functionality
- Optimized for token efficiency

### `llms-full.txt` (Complete)
The complete documentation in a single file, ideal for comprehensive AI assistance and in-depth analysis.

**Access:** /llms-full.txt

This format includes:
- Complete documentation content
- All examples and detailed explanations
- Full API references and guides
- Suitable for complex queries and comprehensive understanding

## Access Pages As Markdown

Each documentation page is also available as clean markdown by appending `.md` to any documentation URL path.

For example:

- Original URL: `https://rivet.dev/docs/actors`
- Markdown URL: `https://rivet.dev/docs/actors.md`
## Edge Networking

# Edge Networking

Actors automatically run near your users on your provider's global network.

	At the moment, edge networking is only supported on Rivet Cloud & Cloudflare Workers. More self-hosted platforms are on the roadmap.

## Region selection

### Automatic region selection

By default, actors will choose the nearest region based on the client's location.

Under the hood, Rivet and Cloudflare use [Anycast routing](https://en.wikipedia.org/wiki/Anycast) to automatically find the best location for the client to connect to without relying on a slow manual pinging process.

### Manual region selection

The region an actor is created in can be overridden using region options:

```typescript client.ts
const client = createClient(/* endpoint */);

// Create actor in a specific region
const actor = await client.example.get(
});
```

See [Create  Manage Actors](/docs/actors/communicating-between-actors) for more information.
## Logging

# Logging

Actors provide a built-in way to log complex data to the console.

Using the context's log object (`c.log`) allows you to log complex data using structured logging.

Using the actor logging API is completely optional.

## Log levels

There are 7 log levels:

| Level  | Call                            | Description                                                      |
| ------ | ------------------------------- | ---------------------------------------------------------------- |
| Fatal  | `c.log.fatal(message, ...args);`   | Critical errors that prevent core functionality                 |
| Error  | `c.log.error(message, ...args);`    | Errors that affect functionality but allow continued operation  |
| Warn   | `c.log.warn(message, ...args);`     | Potentially harmful situations that should be addressed         |
| Info   | `c.log.info(message, ...args);`     | General information about significant events & state changes    |
| Debug  | `c.log.debug(message, ...args);`    | Detailed debugging information, usually used in development     |
| Trace  | `c.log.trace(message, ...args);`    | Very detailed debugging information, usually for tracing flow   |
| Silent | N/A                             | Disables all logging output                                     |

## Structured logging

The built-in logging API (using `c.log`) provides structured logging to let you log key-value
pairs instead of raw strings. Structured logs are readable by both machines &
humans to make them easier to parse & search.

When using `c.log`, the actor's name, key, and actor ID are automatically included in every log output. This makes it easy to filter and trace logs by specific actors in production environments.

### Examples

```typescript
// Just a message
c.log.info('server started');
// Prints: level=INFO actor=myActor key=foo actorId=44096d46632fd087 msg="server started"

// Message with an object
c.log.info('user connected', );
// Prints: level=INFO actor=myActor key=foo actorId=44096d46632fd087 msg="user connected" userId=123 ip="192.168.1.1"

// Just an object (no message)
c.log.info();
// Prints: level=INFO actor=myActor key=foo actorId=44096d46632fd087 action="purchase" amount=99.99 currency="USD"
```

The logging system is built on [Pino](https://getpino.io/#/docs/api?id=logger), a high-performance structured logger for Node.js.

## Configuration

### Environment Variables

You can configure logging behavior using environment variables:

| Variable | Description | Values | Default |
| -------- | ----------- | ------ | ------- |
| `LOG_LEVEL` | Sets the minimum log level to display | `trace`, `debug`, `info`, `warn`, `error`, `fatal`, `silent` | `warn` |
| `LOG_TARGET` | Include the module name that logged the message | `1` to enable, `0` to disable | `0` |
| `LOG_TIMESTAMP` | Include timestamp in log output | `1` to enable, `0` to disable | `0` |

Example:
```bash
LOG_LEVEL=debug LOG_TARGET=1 LOG_TIMESTAMP=1 node server.js
```

### Log Level

You can configure the log level programmatically when running your server:

```typescript
registry.start(
})
```

### Custom Pino Logger

You can also provide a custom Pino base logger for more advanced logging configurations:

```typescript
const customLogger = pino(
});

registry.start(
})
```

If using a custom base logger, you must manually configure your own log level in the Pino logger.

For more advanced Pino configuration options, see the [Pino API documentation](https://getpino.io/#/docs/api?id=export).

### Disable Welcome Message

You can disable the default RivetKit welcome message with:

```typescript
registry.start()
```
## Self-Hosting

# Self-Hosting

Take full control of your Rivet deployment with flexible hosting options and storage drivers.

## Hosting Providers

  Deploy Rivet applications with Railway's simple platform-as-a-service

  Run Rivet actors on Cloudflare's edge computing platform

  Managed Rivet hosting with enterprise features and support
## System Architecture

# System Architecture

	This document is for advanced users seeking to understand the internal architecture of RivetKit. Most users do not need to read this document.

## Request Lifecycle

### Base Architecture

### Coordinated Architecture
## Webhooks

# Webhooks

TODO
## Overview

# Overview

Rivet is a library for long-lived processes with durable state, realtime, and scalability. It is easily self-hostable and works with your infrastructure.

## Libraries

  Long-lived processes with durable state, realtime, and hibernation

## Use Cases

))}

## Deploy Options

## Integrations

))}

## Support

  Chat with the community and get realtime help from Rivet engineers

  File bugs or request features directly in our tracker
## Better Auth

# Better Auth

Integrate Rivet with Better Auth for authentication

Better Auth provides a comprehensive authentication solution that integrates seamlessly with Rivet Actors using the `onAuth` hook.

	Check out the complete example

## Installation

Install Better Auth alongside Rivet:

```bash
npm install better-auth better-sqlite3
npm install -D @types/better-sqlite3

# For React integration
npm install @rivetkit/react
```

	This example uses SQLite to keep the example. In production, replace this with a database like Postgres. Read more about [configuring your database in Better Auth](https://www.better-auth.com/docs/installation#configure-database).

## Backend Setup

Create your authentication configuration:

```typescript auth.ts
const auth = betterAuth(,
});
```

Create and apply the database schema:

```bash
# Generate migration files
pnpm dlx @better-auth/cli@latest generate --config auth.ts

# Apply migrations to create the database tables
pnpm dlx @better-auth/cli@latest migrate --config auth.ts -y
```

Use the `onAuth` hook to validate sessions:

```typescript registry.ts
const chatRoom = actor( = opts;
    
    // Use Better Auth to validate the session
    const authResult = await auth.api.getSession();
    if (!authResult) throw new Unauthorized();
    
    // Return user data to be available in actor
    return ;
  },
  
  state: ,
  
  actions:  = c.conn.auth;
      
      const newMessage = ;
      
      c.state.messages.push(newMessage);
      c.broadcast("newMessage", newMessage);
      
      return newMessage;
    },
    
    getMessages: (c) => c.state.messages,
  },
});

const registry = setup(,
});
```

Configure your server to handle Better Auth routes and Rivet:

```typescript
// server.ts
registry.start();
const app = new Hono();

// Configure CORS for Better Auth + Rivet
app.use("*", cors());

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/**", (c) => 
  auth.handler(c.req.raw)
);

// Start Rivet server
serve(app);
```

## Frontend Integration

Create a Better Auth client for your frontend:

```typescript
// auth-client.ts
const authClient = createAuthClient();
```

Create login/signup forms:

```tsx
// AuthForm.tsx
function AuthForm() );
      } else );
      }
    } catch (error) 
  };

  return (

          required
        />
      )}
      
       setEmail(e.target.value)}
        required
      />
      
       setPassword(e.target.value)}
        required
      />

       setIsLogin(!isLogin)}
      >

  );
}
```

Use authenticated sessions with Rivet:

```tsx
// ChatRoom.tsx
const  = createRivetKit("http://localhost:8080");

interface ChatRoomProps  };
  roomId: string;
}

function ChatRoom(: ChatRoomProps) );

  const sendMessage = async () => ;

  return (

        Welcome, !
         authClient.signOut()}>Sign Out

        : 
          
        ))}

         setNewMessage(e.target.value)}
          onKeyPress=
          placeholder="Type a message..."
        />
        Send

  );
}
```

## Advanced Features

### Role-Based Access

Add role checking to your actors:

```typescript
const adminActor = actor();
    if (!authResult) throw new Unauthorized();
    
    return ;
  },
  
  actions:  = c.conn.auth;
      if (user.role !== "admin") 

      // Admin-only action
      // ... implementation
    },
  },
});
```

### Session Management

Handle session expiration gracefully:

```tsx
// hooks/useAuth.ts
function useAuthWithRefresh()  = authClient.useSession();
  
  useEffect(() => 
  }, [error]);
  
  return session;
}
```

## Production Deployment

For production, you'll need a database from a provider like [Neon](https://neon.tech/), [PlanetScale](https://planetscale.com/), [AWS RDS](https://aws.amazon.com/rds/), or [Google Cloud SQL](https://cloud.google.com/sql).

Configure your production database connection:

```typescript
// auth.ts
const auth = betterAuth(),
  trustedOrigins: [process.env.FRONTEND_URL],
  emailAndPassword: ,
});
```

Set the following environment variables for production:

```bash
DATABASE_URL=postgresql://username:password@localhost:5432/myapp
FRONTEND_URL=https://myapp.com
BETTER_AUTH_SECRET=your-secure-secret-key
BETTER_AUTH_URL=https://api.myapp.com
```

Read more about [configuring Postgres with Better Auth](https://www.better-auth.com/docs/adapters/postgresql).

	Don't forget to re-generate & re-apply your database migrations if you change the database in your Better Auth config.
## Cloudflare Workers

# Cloudflare Workers

Deploy Rivet Actors to Cloudflare Workers with Durable Objects for global edge computing with persistent state.

## Feature Support

| Feature | Supported |
| --- | --- |
| Horizontal scaling | Yes |
| WebSockets | Yes |
| SSE | Yes |
| Edge | Yes |
| Scheduling | Yes |

## Setup

Install the Cloudflare Workers driver:

```bash
npm install @rivetkit/cloudflare-workers
```

Update your server code to support Cloudflare Workers:

```typescript }
// Setup router
const app = new Hono } }>();

// Example HTTP endpoint
app.post("/increment/:name", async (c) => `);
});

const  = createHandler(registry, );
;
```

```typescript }
const  = createHandler(registry);
;
```

Update your `wrangler.json` configuration to support `ACTOR_DO` and `ACTOR_KV` bindings:

```json }

  ],
  "durable_objects": 
    ]
  },
  "kv_namespaces": [
    
  ]
}
```

**Configuration Requirements:**

- `ACTOR_DO` - Durable Object binding for actor persistence
- `ACTOR_KV` - KV namespace binding for metadata storage
- `nodejs_compat` - Required compatibility flag
- Migration with `ActorHandler` class definition

Deploy your application to Cloudflare Workers:

```bash
wrangler deploy
```

Your actors will now run on Cloudflare's global edge network with persistent state backed by Durable Objects.
## Elysia

# Elysia

Integrate Rivet with Elysia for fast TypeScript web applications

Elysia is a fast and type-safe web framework for Bun. Rivet integrates seamlessly with Elysia using the `.mount()` method.

	Check out the complete example

## Installation

Install Elysia alongside Rivet:

```bash
npm install elysia
# or with bun
bun add elysia
```

## Basic Setup

Set up your Rivet Actors:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Mount Rivet into your Elysia application:

```typescript
// server.ts
const  = registry.start();

// Setup Elysia app
const app = new Elysia()
  // Add your API routes
  .post("/increment/:name", async () => `;
  })
  .get("/count/:name", async () => ;
  })
  .listen(8080);

console.log("Server running at http://localhost:8080");
```
## Express

# Express

Integrate Rivet with Express.js for Node.js web applications

Express.js is a popular Node.js web framework. Rivet integrates seamlessly with Express using middleware mounting.

	Check out the complete example

## Installation

Install Express alongside Rivet:

```bash
npm install express
npm install -D @types/express
```

## Basic Setup

Set up your Rivet Actor:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

Mount Rivet into your Express application:

```typescript
// server.ts
// Start Rivet
const  = registry.start();

// Setup Express app
const app = express();

// Enable JSON parsing
app.use(express.json());

// Add your API routes
app.post("/increment/:name", async (req, res) =>  = req.body;
  
  try );
  } catch (error) );
  }
});

app.get("/count/:name", async (req, res) => );
  } catch (error) );
  }
});

app.listen(8080, () => );
```
## Hono

# Hono

Integrate Rivet with Hono for ultra-fast web applications

Hono is an ultra-fast web framework that works on any runtime. Rivet integrates seamlessly with Hono through the `serve()` method.

	Check out the complete example

## Installation

Install Hono alongside Rivet:

```bash
npm install hono
```

## Basic Setup

Set up your Rivet Actor:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
  },
});

const registry = setup(,
});
```

```typescript
// server.ts
// Start Rivet
const  = registry.start();

// Setup Hono app
const app = new Hono();

// Add your API routes
app.post("/increment/:name", async (c) => ));
  const amount = body.amount || 1;
  
  try );
  } catch (error) , 500);
  }
});

app.get("/count/:name", async (c) => );
  } catch (error) , 500);
  }
});

// Start server
serve(app);
```
## Integrations

# Integrations

Rivet provides seamless integrations with popular frameworks and tools to help you build modern applications.

      ))}

))}
## Next.js

# Next.js

Next.js is a powerful React framework that allows you to build server-rendered applications with ease. The Rivet Next.js client enables you to connect to and interact with actors in your Next.js applications.

	Check out the complete example

	Use the RivetKit React client to connect to actors

## Basic Usage

Install the RivetKit Next.js package:

Create a simple counter actor:

```ts }
const counter = actor(,
	actions: ,
		getCount: (c) => c.state.count,
	},
});

const registry = setup(,
});
```

```ts }
const maxDuration = 300;

// Export the Next.js handler for the API routes
const  = toNextHandler(registry);
```

## API Reference

### `toNextHandler`
Converts a RivetKit server to a Next.js handler for API routes.

```ts
const counter = actor(,
	actions: ,
});

const registry = setup(,
});

const maxDuration = 300;

const  = toNextHandler(registry);
```

#### Parameters
- `server`: The RivetKit server instance created from your registry.

#### Returns
- An object containing Next.js-compatible handlers for the HTTP methods.
## Pino

# Pino

Rivet's actor system uses [Pino](https://getpino.io/), a high-performance structured logging library for Node.js, to power its logging infrastructure.

For detailed information on how to use and configure logging in your actors, see the [Logging documentation](/docs/general/logging).

## Learn More

- [Logging in RivetKit](/docs/general/logging) - Complete guide to using logs in your actors
- [Pino Documentation](https://getpino.io/#/docs/api) - Official Pino API documentation
## tRPC

# tRPC

Integrate Rivet with tRPC for end-to-end type-safe APIs

tRPC provides end-to-end type safety for your APIs. Rivet integrates seamlessly with tRPC, allowing you to create type-safe procedures that call Rivet Actors.

	Check out the complete example

## Installation

Install tRPC alongside Rivet:

```bash
npm install @trpc/server @trpc/client zod
npm install -D @trpc/next # if using Next.js
```

## Basic Setup

Set up your Rivet Actors:

```typescript
// registry.ts
const counter = actor(,
  actions: ,
    getCount: (c) => c.state.count,
    reset: (c) => ,
  },
});

const registry = setup(,
});
```

Create your tRPC router that uses Rivet:

```typescript
// server.ts
// Start Rivet
const  = registry.start();

// Initialize tRPC
const t = initTRPC.create();

// Create tRPC router with Rivet integration
const appRouter = t.router())
      .mutation(async () => ;
      }),
    
    get: t.procedure
      .input(z.object())
      .query(async () => ;
      }),
    
    reset: t.procedure
      .input(z.object())
      .mutation(async () => ;
      }),
  }),
});

// Export type for client
type AppRouter = typeof appRouter;

// Create HTTP server
const server = createHTTPServer();

server.listen(3001);
console.log("tRPC server listening at http://localhost:3001");
```

Create a type-safe tRPC client:

```typescript
// client.ts
const trpc = createTRPCProxyClient(),
  ],
});

// Usage examples
async function examples() );
  console.log(result); // 
  
  // Get counter value
  const value = await trpc.counter.get.query();
  console.log(value); // 
  
  // Reset counter
  const reset = await trpc.counter.reset.mutate();
  console.log(reset); // 
}
```
## Vitest

# Vitest

See [Testing](/docs/actors/testing) documentation.
## Configuration

# Configuration

Rivet Engine can be configured through environment variables or configuration files. The configuration system is defined in `packages/common/config/`.

## Configuration Loading

Rivet supports multiple configuration sources:

1. **Default Values**: All configurations have sensible defaults
2. **File-based Configuration**: JSON, JSON5, JSONC, YAML, and YML files
3. **Environment Variables**: Using `RIVET__` prefix with `__` as separator (e.g., `RIVET__database__postgres__url`)
4. **Multi-path Loading**: Can load from multiple configuration files
5. **System Paths**: Platform-specific system configuration directories:
   - Linux: `/etc/rivet/`
   - macOS: `/Library/Application Support/rivet/`
   - Windows: `C:\ProgramData\rivet\`

## Definition

```typescript
interface RivetConfig ;
    };
  };

  // Private API service configuration
  api_peer?: ;

  // Logging configuration
  logs?: ;

  // Multi-datacenter topology
  topology?: ;

  // Database backend configuration
  database?: 
    | ;
      }
    | ;
      };

  // Message pub/sub system
  pubsub?: 
    | ;
      }
    | ;
      }
    | ;
      };

  // Caching layer configuration
  cache?: ;

  // ClickHouse analytics database (optional)
  clickhouse?: ;
    };
  };

  // Vector HTTP endpoint (optional)
  vector_http?: ;
}
```
## Connecting Your Backend to Rivet Engine

# Connecting Your Backend to Rivet Engine

Unless exlpicitly configured, Rivet will default to running on the local file system without using the Rivet Engine. This is perfect for local development and testing.

When ready to scale the backend, RivetKit can connect to a Rivet Engine instance using the `RIVET_ENGINE` environment variable.

	The engine is not required at any point during development. It is only required to scale RivetKit to multiple nodes.

## Connecting Runners

To connect a runner to your Rivet Engine, set the `RIVET_ENGINE` environment variable:

```bash
RIVET_ENGINE=http://your-engine-host:6420 npm run dev
```

Once connected:
- The runner appears in the Runners tab of the dashboard
- Your actor names show up in the sidebar
- The engine begins routing traffic to your runner

## Environment Variables

### `RIVET_ENGINE`
The endpoint of your Rivet Engine instance.

```bash
# Local development
RIVET_ENGINE=http://localhost:6420

# Production
RIVET_ENGINE=https://engine.your-domain.com
```

### `RIVET_NAMESPACE`
The namespace to run actors in. Useful for multi-tenant deployments.

```bash
RIVET_NAMESPACE=production
```

### `RIVET_RUNNER`
A name for the runner to allow filtering which nodes to run actors on.

```bash
RIVET_RUNNER=worker-01
```

### `RIVET_RUNNER_KEY`
A unique key for the runner. If another runner connects with the same key, the previous one is disconnected. This is useful for handling zombie runners that weren't shut down gracefully.

```bash
RIVET_RUNNER_KEY=unique-runner-key-123
```

  Generate a unique runner key using: `uuidgen` or `openssl rand -hex 16`

## Connection Examples

### Testing Setup

You do not need the engine for local development, but it can be helpful for testing your production-readiness: 

```bash
# Start the engine
docker run -p 6420:6420 rivetkit/engine

# In another terminal, start your runner
RIVET_ENGINE=http://localhost:6420 npm run dev
```

### Production Setup

```bash
# Assume the engine is running at 1.2.3.4

# On runner nodes
RIVET_ENGINE=http://1.2.3.4 \
RIVET_NAMESPACE=production \
RIVET_RUNNER=worker-$(hostname) \
RIVET_RUNNER_KEY=$(cat /etc/machine-id) \
npm run start
```
## Docker Compose

# Docker Compose

## Quick Start

Run with ephemeral storage:

```yaml
services:
  rivet-engine:
    image: rivetkit/engine:latest
    ports:
      - "6420:6420"
    restart: unless-stopped
```

Run with persistent storage:

```yaml
services:
  rivet-engine:
    image: rivetkit/engine:latest
    ports:
      - "6420:6420"
    volumes:
      - rivet-data:/data
    environment:
      RIVET__FILE_SYSTEM__PATH: "/data"
    restart: unless-stopped

volumes:
  rivet-data:
```

Start the services:

```bash
docker-compose up -d
```

## Configuration

### Environment Variables

Configure Rivet using environment variables in your compose file:

```yaml
services:
  rivet-engine:
    image: rivetkit/engine:latest
    ports:
      - "6420:6420"
    volumes:
      - rivet-data:/data
    environment:
      RIVET__POSTGRES__URL: "postgresql://postgres:password@localhost:5432/db"
    restart: unless-stopped

volumes:
  rivet-data:
```

Or use a `.env` file:

```txt
# .env
POSTGRES_PASSWORD=secure_password
RIVET__POSTGRES__URL=postgresql://rivet:secure_password@postgres:5432/rivet
```

Reference in compose:

```yaml
services:
  rivet-engine:
    env_file:
      - .env
```

### Config File

Mount a JSON configuration file:

```yaml
services:
  rivet-engine:
    image: rivetkit/engine:latest
    ports:
      - "6420:6420"
    volumes:
      - ./rivet-config.json:/etc/rivet/config.json:ro
      - rivet-data:/data
    restart: unless-stopped

volumes:
  rivet-data:
```

Create the config file (`rivet-config.json`):

```json

}
```

## Production Setup

#### With PostgreSQL

```yaml
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: rivet
      POSTGRES_USER: rivet
      POSTGRES_PASSWORD: rivet_password
    volumes:
      - postgres-data:/var/lib/postgresql/data
    restart: unless-stopped

  rivet-engine:
    image: rivetkit/engine:latest
    ports:
      - "6420:6420"
    environment:
      RIVET__POSTGRES__URL: postgresql://rivet:rivet_password@postgres:5432/rivet
    depends_on:
      - postgres
    restart: unless-stopped

volumes:
  postgres-data:
```

## Next Steps

- See [Configuration](/docs/self-hosting/configuration) for all options
## Docker Container

# Docker Container

## Quick Start

Run with ephemeral storage:

```bash
docker run -p 6420:6420 rivetkit/engine
```

Run with persistent storage:

```bash
docker run \
  -p 6420:6420 \
  -v rivet-data:/data \
  -e RIVET__FILE_SYSTEM__PATH="/data" \
  rivetkit/engine
```

## Configuration

### Environment Variables

Configure Rivet using environment variables:

```bash
docker run -p 6420:6420 \
  -v rivet-data:/data \
  -e RIVET__POSTGRES__URL="postgresql://postgres:password@localhost:5432/db" \
  rivetkit/engine
```

### Config File

Mount a JSON configuration file:

```bash
# Create config file
cat  rivet-config.json

}
EOF

# Run with mounted config
docker run -p 6420:6420 \
  -v rivet-data:/data \
  -v $(pwd)/rivet-config.json:/etc/rivet/config.json:ro \
  rivetkit/engine
```

## Production Setup

### With PostgreSQL

```bash
# Create network
docker network create rivet-net

# Run PostgreSQL
docker run -d \
  --name postgres \
  --network rivet-net \
  -e POSTGRES_DB=rivet \
  -e POSTGRES_USER=rivet \
  -e POSTGRES_PASSWORD=rivet_password \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:15

# Run Rivet Engine
docker run -d \
  --name rivet-engine \
  --network rivet-net \
  -p 6420:6420 \
  -e RIVET__POSTGRES__URL="postgresql://rivet:rivet_password@postgres:5432/rivet" \
  rivetkit/engine
```

## Next Steps

- Use [Docker Compose](/docs/self-hosting/docker-compose) for multi-container setups
- See [Configuration](/docs/self-hosting/configuration) for all options
## Self-Hosting Overview

# Self-Hosting Overview

Rivet consists of several core components that work together to provide a complete actor orchestration platform. The Rivet Engine is the core of self-hosting and is used for orchestrating actors at scale:

	Self-hosting is not required to deploy Rivet applciations in your own cloud. Please see the [deploy documentation](/docs/deploy) if trying to deploy a Rivet application.

## Core Components

- **Your Backend** - Your application server that handles user requests and includes a runner component that executes actor code
- **Rivet Engine** - Main orchestration service that manages actor lifecycle, routes messages, and provides APIs
- **Storage** - Persistence layer for actor state and messaging infrastructure for real-time communication

## Architecture

```txt }
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│Your Backend │◀───▶│Rivet Engine │◀───▶│   Storage   │
│ (w/ runner) │     │             │     │  (DB/File)  │
└─────────────┘     └─────────────┘     └─────────────┘
```

## Storage Backends

Rivet supports multiple storage backends:
- **File System** - Default, suitable for single-node deployments
- **PostgreSQL** - Recommended for production
- **FoundationDB** - Enterprise option for massive scale

## Deployment Platforms

Deploy Rivet on your preferred platform:

- [Docker Container](/docs/self-hosting/docker-container)
- [Docker Compose](/docs/self-hosting/docker-compose)
- [Railway](/docs/self-hosting/railway)
- Kubernetes
- AWS Fargate
- Google Cloud Run
- Hetzner
- VM & Bare Metal

_Self-hosting guides coming soon._

## Next Steps

- [Install Rivet Engine](/docs/self-hosting/install)
- [Connect your backend](/docs/self-hosting/connect-backend)
- [Configure your deployment](/docs/self-hosting/configuration)
- [Multi-region setup](/docs/self-hosting/multi-region)
## Installing Rivet Engine

# Installing Rivet Engine

## Docker

```bash
docker run -p 6420:6420 rivetkit/engine
```

For more options:
- [Docker Container](/docs/self-hosting/docker-container) - Persistent storage, configuration, production setup
- [Docker Compose](/docs/self-hosting/docker-compose) - Multi-container deployments with PostgreSQL

## Prebuilt Binaries

	Prebuilt binaries coming soon

## Build From Source

```bash
git clone https://github.com/rivet-dev/engine.git
cd rivet
cargo build --release -p rivet-engine
./target/release/rivet-engine
```
## Kubernetes Deployment

# Kubernetes Deployment

	Documentation coming soon
## Multi-Region

# Multi-Region

Rivet Engine supports scaling transparently across multiple regions.

	Documentation coming soon
## Railway Deployment

# Railway Deployment

Railway provides a simple platform for deploying Rivet Engine with automatic scaling and managed infrastructure.

## Video Tutorial

## Quick Deploy

Choose the template that best fits your needs:

| **Rivet Template** | **Rivet Starter** |
|-------------------|-------------------|
| [![Deploy on Railway](https://railway.com/button.svg)](https://railway.com/deploy/rivet?referralCode=RC7bza&utm_medium=integration&utm_source=template&utm_campaign=generic) | [![Deploy Rivet Starter](https://railway.com/button.svg)](https://railway.com/deploy/rivet-starter) |
| **Blank template** to start fresh | **Complete example** with chat app |
| - Rivet Engine | - Pre-configured Rivet Engine |
| - PostgreSQL database | - Example chat application with Actors |
| - Basic configuration | - PostgreSQL database |
| - Manual setup required | - Rivet Inspector for debugging |
| | - Ready to run immediately |

You can also use the [Rivet Railway template](https://github.com/rivet-dev/template-railway) as a starting point for your application.

After deploying either template, you can find the `RIVET__AUTH__ADMIN_TOKEN` under the **Variables** tab in the Railway dashboard. This token is required to access the Rivet Inspector.

## Manual Deployment

### Prerequisites

1. [Railway account](https://railway.app)
2. [Railway CLI](https://docs.railway.app/develop/cli) (optional)

### Step 1: Create New Project

```bash
# Using Railway CLI
railway init

# Or create via dashboard
# https://railway.app/new
```

### Step 2: Add Services

#### Deploy PostgreSQL Database

1. Click "New Service" → "Database" → "PostgreSQL"
2. Railway automatically provisions and configures PostgreSQL
3. Note the connection string from the service variables

#### Deploy Rivet Engine

1. Click "New Service" → "Docker Image"
2. Set image: `rivetkit/engine:latest`
3. Configure environment variables:
    - `RIVET__POSTGRES__URL=$}`

### Step 3: Deploy Your Application

Follow the [Railway Quick Start guide](https://docs.railway.com/quick-start) to deploy your repository:

1. Connect your GitHub account to Railway
2. Select your repository containing your Rivet application
3. Railway will automatically detect and deploy your application
4. Configure environment variables for your application:
    - `RIVET_ENGINE=$}` - Points to the Rivet Engine service's private domain
## AI Agents

# AI Agents

## Challenges of Building AI Agents

Main pain points:

- **Long-running & complex workflows**: Orchestrating multi-step tool calls, handling timeouts, and maintaining state consistency across operations
- **Fault tolerance & recovery**: Gracefully handling agent failures, network issues, and LLM API errors without losing conversation state
- **Real-time streaming**: Building infrastructure for streaming responses while handling backpressure and connection management
- **State persistence & isolation**: Managing conversation history and agent memory per user without complex database setups
- **Observability & debugging**: Understanding agent decision-making, tracking tool usage, and debugging complex behaviors

## How Rivet Solves This

Rivet provides a complete actor-based runtime designed specifically for stateful AI agents, addressing each challenge:

**Long-running & complex workflows**: Actors naturally handle multi-step operations with built-in state management. Tool calls execute within the actor context, maintaining consistency across all operations. Workflows can span hours or days without losing state.

```typescript
const aiAgent = actor(,

  actions: 
      }
    }
  }
});
```

**Fault tolerance & recovery**: State automatically persists to durable storage. If an agent crashes, it resumes exactly where it left off with full conversation history and context intact. Network failures and LLM API errors don't lose progress.

**Real-time streaming**: Built-in WebSocket support with automatic connection management. Stream LLM responses directly to clients without building custom infrastructure. Backpressure and reconnection handled automatically. Learn more about [events](/docs/actors/events).

```typescript
// Stream responses directly to connected clients
c.broadcast("stream", );
```

**State persistence & isolation**: Each agent actor is automatically isolated per user/conversation. State persists without external databases - conversation history, tool results, and context are maintained in-actor memory with automatic durability. Read about [actor lifecycle](/docs/actors/lifecycle).

**Observability & debugging**: Full visibility into agent behavior through structured logging, metrics, and state inspection. Track every tool call, decision point, and state change. Debug production issues with complete audit trails.

```typescript
// Automatic tracing of all actions and state changes
c.log("Tool executed", );
```

**Bonus - No cold starts**: Agents hibernate when idle and wake instantly when needed, keeping conversation context ready without paying for idle compute. See [actions](/docs/actors/actions) for more details.

## Full Example Projects
## Background Jobs

# Background Jobs

## Challenges of Building Background Job Systems

Common tools: Celery, Bull, Sidekiq, AWS SQS, RabbitMQ, Redis queues, cron jobs

Main pain points:
- Managing separate job queue infrastructure and worker processes
- Tracking job state and results across distributed systems
- Handling job retries, failures, and dead letter queues
- Coordinating scheduled and recurring jobs with cron syntax
- Persisting job state and intermediate results during long-running tasks

## How Rivet Solves This

Rivet actors provide built-in job scheduling and execution with automatic state persistence and no external queue infrastructure.

**Self-Contained Job Execution**: Each actor can schedule and execute background tasks with full access to its persistent state.

```typescript
const jobProcessor = actor( as Record,
    queue: [] as string[]
  },

  actions: ;
      c.state.queue.push(jobId);

      if (delay)  else 

      return jobId;
    },

    processJob: async (c, jobId: string) => );

      try ;
        c.broadcast("jobUpdate", );
      } catch (error) ;
        c.broadcast("jobUpdate", );
      }
    }
  }
});
```

**Built-in Scheduling**: Schedule delayed and recurring jobs using [scheduled actions](/docs/actors/schedule) without cron or external schedulers.

**Durable State**: Job state persists automatically, surviving restarts and failures. See [state management](/docs/actors/state).

**Realtime Progress**: Stream job progress and results to clients using [events](/docs/actors/events).

**No Queue Infrastructure**: Execute jobs directly within actors without Redis, RabbitMQ, or other message queues.

## Full Example Projects
## Bots

# Bots

## Challenges of Building Bots

Common tools: Discord.js, Slack Bolt, Telegraf, traditional web servers with databases, message queues

Main pain points:
- Managing bot state and conversation context across sessions requires external storage
- Handling concurrent conversations with multiple users while maintaining per-user state
- Keeping bots online 24/7 on traditional servers is expensive
- Complex infrastructure for event-driven responses and background tasks
- Difficulty maintaining WebSocket connections to chat platforms reliably

## How Rivet Solves This

Rivet provides long-lived actors that maintain persistent connections and state for chat bots without managing infrastructure.

**Always-On Bot Instances**: Each bot actor stays alive with persistent state, maintaining connections to chat platforms like Discord, Slack, or Telegram. Actors hibernate when idle but wake instantly when messages arrive.

```typescript
const discordBot = actor( as Record,
    userPreferences:  as Record
  },

  actions: ;

      return response;
    }
  }
});
```

**Persistent State**: Bot memory, user preferences, and conversation history persist automatically without external databases. See [state management](/docs/actors/state).

**Background Tasks**: Use [scheduled actions](/docs/actors/schedule) to run periodic tasks like reminders, notifications, or cleanup jobs.

**Realtime Events**: Send and receive messages in realtime using WebSocket connections. Learn more about [events](/docs/actors/events).

## Full Example Projects
## Realtime Docs

# Realtime Docs

## Challenges of Building Realtime Collaborative Documents

Common tools: Yjs, Automerge, operational transforms, WebSocket servers, Redis for pub/sub, database for persistence

Main pain points:
- Coordinating realtime updates across multiple users requires complex pub/sub infrastructure
- Persisting document state and CRDT data structures to databases adds latency
- Managing conflict resolution and synchronization logic is complex
- Scaling WebSocket connections and state management across servers
- Handling offline users and reconnection scenarios

## How Rivet Solves This

Rivet provides actors that maintain CRDT document state in memory and broadcast updates in realtime without external infrastructure.

**In-Memory CRDTs**: Store Yjs or Automerge documents directly in actor state for ultra-fast reads and writes with zero database latency.

```typescript
const collaborativeDoc = actor(,

  actions: );
    }
  }
});
```

**Built-in Realtime**: WebSocket connections are built into actors, eliminating the need for separate pub/sub systems. See [events](/docs/actors/events).

**Automatic Persistence**: Document state persists automatically without database round trips. Learn about [state management](/docs/actors/state).

**Multi-User Support**: Track connected users and their cursor positions using [connection state](/docs/actors/connections).

## Full Example Projects
## Per-User Database

# Per-User Database

## Challenges of Building Per-User Databases

Common tools: PostgreSQL with row-level security, MongoDB with tenant isolation, SQLite per-user files, DynamoDB with partition keys

Main pain points:
- High latency from database round trips for every read/write operation
- Complex query patterns to ensure tenant isolation and prevent data leaks
- Scaling challenges when users have large datasets
- Managing database connections and connection pooling per-tenant
- Expensive database operations for simple key-value access patterns

## How Rivet Solves This

Rivet actors provide isolated in-memory databases for each user with automatic persistence and zero-latency access.

**Isolated User State**: Each user gets their own actor with completely isolated state, eliminating tenant isolation concerns.

```typescript
const userDatabase = actor( as Record,
    settings: ,
    metadata: 
  },

  actions: ,

    get: (c, key: string) => ,

    query: (c, filter: (doc: any) => boolean) => ));
    }
  }
});
```

**Zero-Latency Reads**: State lives in memory on the same machine as compute, making reads instant with no database round trips. See [state management](/docs/actors/state).

**Automatic Persistence**: Data persists automatically without manual save operations or database drivers.

**Built-in SQLite Support**: Use SQLite databases within actors for relational data. See [external SQL](/docs/actors/external-sql) for integration with traditional databases.

**Realtime Updates**: Broadcast data changes to connected clients using [events](/docs/actors/events).

## Full Example Projects
## Multiplayer Game

# Multiplayer Game

## Challenges of Building Multiplayer Games

Common tools: Unity Netcode, Photon, Colyseus, custom WebSocket servers, Redis for state, game server hosting

Main pain points:
- Managing game state synchronization across multiple players with low latency
- Handling player connections, disconnections, and reconnections gracefully
- Scaling game servers and matchmaking infrastructure
- Persisting game state between sessions
- Complex networking code for state replication and conflict resolution

## How Rivet Solves This

Rivet actors provide authoritative game servers with built-in state management and realtime networking.

**Authoritative Game State**: Each game room runs in its own actor with server-authoritative state management.

```typescript
const gameRoom = actor( as Record,
    gameState: "waiting" as "waiting" | "playing" | "ended",
    startTime: 0
  },

  createConnState: (c, opts, params: ) => (),

  actions: );
      }
    },

    startGame: (c) => );
    }
  }
});
```

**Low-Latency Updates**: Broadcast game state changes in realtime using WebSockets with built-in [events](/docs/actors/events).

**State Persistence**: Game state persists automatically, allowing players to rejoin games after disconnections. Learn about [state management](/docs/actors/state).

**Connection Tracking**: Track connected players and handle disconnections gracefully using [connections](/docs/actors/connections).

**Tick-Based Updates**: Use [scheduled actions](/docs/actors/schedule) for fixed-rate game loops and physics updates.

## Full Example Projects
## Rate Limiting

# Rate Limiting

## Challenges of Building Rate Limiting

Common tools: Redis with sliding windows, token bucket algorithms, NGINX rate limiting, Kong, custom middleware

Main pain points:
- Coordinating rate limits across distributed servers requires shared state
- High latency from Redis lookups on every request
- Complex sliding window or token bucket implementations
- Handling rate limit resets and per-user quotas
- Managing rate limit state for millions of users

## How Rivet Solves This

Rivet actors provide low-latency distributed rate limiting with in-memory counters and automatic persistence.

**Per-User Rate Limiting**: Each user gets their own actor to track request counts and enforce limits with zero-latency access.

```typescript
const rateLimiter = actor(,

  actions: ;
      }

      // Add new request
      c.state.requests.push(now);

      return ;
    },

    getStatus: (c) => ;
    }
  }
});
```

**Zero-Latency Checks**: Rate limit counters live in memory, eliminating Redis round trips for every request.

**Automatic Persistence**: Counter state persists automatically without manual Redis operations. See [state management](/docs/actors/state).

**Flexible Algorithms**: Implement sliding windows, token buckets, or custom rate limiting logic directly in actor code.

**Per-User Isolation**: Each user's rate limit is isolated in their own actor, providing natural horizontal scaling.

**Realtime Notifications**: Send rate limit warnings to users via [events](/docs/actors/events).

## Full Example Projects
## Local-First Sync

# Local-First Sync

## Challenges of Building Local-First Sync

Common tools: ElectricSQL, PowerSync, custom sync protocols, CRDTs, WebSockets, PostgreSQL logical replication

Main pain points:
- Complex conflict resolution when syncing offline changes to server
- Managing sync state and tracking changes across devices
- Handling partial syncs and large datasets efficiently
- Infrastructure for WebSocket connections and pub/sub for realtime updates
- Coordinating between client-side databases and server-side storage

## How Rivet Solves This

Rivet actors provide stateful sync coordination with built-in realtime updates and automatic persistence.

**Per-User Sync Actors**: Each user gets a dedicated actor to manage their sync state and coordinate updates across devices.

```typescript
const userSync = actor( as Record,
    lastSyncTimestamp: 0,
    deviceStates:  as Record
  },

  actions: ;

      // Broadcast to other devices
      for (const conn of c.conns) );
        }
      }

      return ;
    }
  },

  createConnState: (c, opts, params: ) => ()
});
```

**Automatic State Persistence**: Sync state persists automatically without external databases. See [state management](/docs/actors/state).

**Realtime Cross-Device Sync**: Broadcast updates to all connected devices instantly using [events](/docs/actors/events).

**Connection Tracking**: Monitor online/offline devices using [connection state](/docs/actors/connections).

**Conflict Resolution**: Implement custom merge strategies directly in actor logic with full access to state history.

## Full Example Projects
## Workflows

# Workflows

## Challenges of Building Workflows

Common tools: Temporal, Cadence, Apache Airflow, AWS Step Functions, custom orchestration systems

Main pain points:
- Complex infrastructure setup and maintenance for workflow orchestration
- Managing state across long-running multi-step processes
- Handling retries, timeouts, and failure recovery across distributed steps
- Coordinating between different services and maintaining transaction boundaries
- High operational cost of running dedicated workflow engines

## How Rivet Solves This

Rivet actors provide built-in workflow capabilities with durable execution and automatic state management without external orchestration systems.

**Durable Execution**: Actor actions automatically persist state between steps, surviving restarts and failures without additional infrastructure.

```typescript
const orderWorkflow = actor(,

  actions: );

      // Step 2: Schedule shipment
      c.schedule.after(1000 * 60 * 60, "shipOrder"); // 1 hour
    },

    shipOrder: async (c) => );
    }
  }
});
```

**Scheduled Steps**: Use [scheduling](/docs/actors/schedule) to delay workflow steps or implement timeouts and reminders.

**State Checkpointing**: State automatically persists after each action, ensuring workflow progress is never lost. Learn about [state management](/docs/actors/state).

**Actor Communication**: Coordinate across services using [actor-to-actor communication](/docs/actors/communicating-between-actors) without message queues.

**Realtime Updates**: Stream workflow progress to clients using [events](/docs/actors/events).

## Full Example Projects