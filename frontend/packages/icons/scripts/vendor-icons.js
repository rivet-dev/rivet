#!/usr/bin/env node
// @ts-nocheck
//
// RIVET ICONS VENDOR SCRIPT
// This script is for Rivet maintainers only.
// It generates icon files from Font Awesome Pro packages.
//
// LEGAL NOTICE: The generated icons are licensed exclusively for use in Rivet
// products and services. Using these icons in any other product or project is
// strictly prohibited and may violate Font Awesome's Terms of Service.
//

const fs = require("node:fs");
const { join, resolve } = require("node:path");
const { spawnSync } = require("node:child_process");
const dedentModule = require("dedent");
const dedent = dedentModule.default || dedentModule;
const esbuild = require("esbuild");

// ============================================================================
// CONFIGURATION
// ============================================================================

const PATHS = {
	root: join(__dirname, ".."),
	get src() {
		return join(this.root, "src");
	},
	get srcNodeModules() {
		return join(this.src, "node_modules");
	},
	get manifest() {
		return join(this.root, "manifest.json");
	},
	get dist() {
		return join(this.root, "dist");
	},
};

const FA_PACKAGES = {
	"@awesome.me/kit-63db24046b": "1.0.27",
	"@fortawesome/pro-regular-svg-icons": "6.6.0",
	"@fortawesome/pro-solid-svg-icons": "6.6.0",
};

const LEGAL_BANNER = dedent`
	// This file is generated by scripts/vendor-icons.js
	// Do not modify this file directly
	// This file includes Font Awesome Pro icons
	//
	// LEGAL NOTICE: This package is licensed exclusively for use in Rivet products
	// and services. Using this package in any other product or project is strictly
	// prohibited and may violate Font Awesome's Terms of Service.


`;

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * @param {string} emoji
 * @param {string} message
 */
function log(emoji, message) {
	console.log(`${emoji} ${message}`);
}

/**
 * @param {string} message
 */
function error(message) {
	console.error(`‚ùå ${message}`);
}

/**
 * @param {string} message
 */
function exitWithError(message) {
	error(message);
	process.exit(1);
}

// ============================================================================
// SETUP PHASE
// ============================================================================

function checkEnvironment() {
	log("üîç", "Checking environment...");
	if (!process.env.FONTAWESOME_PACKAGE_TOKEN) {
		exitWithError(
			"FONTAWESOME_PACKAGE_TOKEN environment variable is required.\n" +
				"This script should only be run by maintainers with a Font Awesome Pro license.",
		);
	}
	log("üîë", "Font Awesome token found");
}

function setupSourceDirectory() {
	log("üìÅ", "Setting up source directory...");
	if (!fs.existsSync(PATHS.src)) {
		fs.mkdirSync(PATHS.src, { recursive: true });
		log("‚ú®", `Created directory: ${PATHS.src}`);
	}
}

function configureFontAwesomeRegistry() {
	log("üìù", "Configuring Font Awesome registry...");

	// Create .npmrc for Font Awesome Pro authentication
	const npmrcContent = dedent`
		@fortawesome:registry=https://npm.fontawesome.com/
		@awesome.me:registry=https://npm.fontawesome.com/
		//npm.fontawesome.com/:_authToken=\${FONTAWESOME_PACKAGE_TOKEN}
		//npm.fontawesome.com/:always-auth=true
	`;
	fs.writeFileSync(join(PATHS.src, ".npmrc"), npmrcContent);

	// Create temporary package.json
	const packageJson = {
		name: "@rivet-gg/internal-icons",
		private: true,
		sideEffects: false,
		dependencies: FA_PACKAGES,
	};
	fs.writeFileSync(
		join(PATHS.src, "package.json"),
		JSON.stringify(packageJson, null, 2),
	);

	log("‚úÖ", "Registry configured");
}

function installFontAwesomePackages() {
	log("üì¶", "Installing Font Awesome Pro packages...");
	log("‚è≥", "This may take a minute...");

	const result = spawnSync("npm", ["install", "--no-package-lock", "--silent"], {
		stdio: "inherit",
		cwd: PATHS.src,
		env: { ...process.env, CI: "0" },
	});

	if (result.status !== 0) {
		exitWithError("Failed to install Font Awesome packages");
	}

	log("‚úÖ", "Packages installed");
}

// ============================================================================
// ICON GENERATION PHASE
// ============================================================================

function loadManifest() {
	log("üìã", "Loading icon manifest...");
	try {
		const manifest = require(PATHS.manifest);
		const packageCount = Object.keys(manifest).length;
		const iconCount = Object.values(manifest).reduce(
			(sum, pkg) => sum + pkg.icons.length,
			0,
		);
		log("üìä", `Loaded ${iconCount} icons from ${packageCount} packages`);
		return manifest;
	} catch (err) {
		const message = err instanceof Error ? err.message : String(err);
		exitWithError(`Failed to load manifest: ${message}`);
	}
}

/**
 * @param {string} pkg
 * @param {string} iconName
 */
function checkIconExists(pkg, iconName) {
	const candidate = join(PATHS.srcNodeModules, pkg, `${iconName}.js`);
	return fs.existsSync(candidate);
}

/**
 * @param {string} pkg
 * @param {string} iconName
 * @param {string} exportName
 */
function generateIconExport(pkg, iconName, exportName) {
	const exists = checkIconExists(pkg, iconName);
	const sourcePkg = exists ? `${pkg}/${iconName}` : "@fortawesome/free-solid-svg-icons/faSquare";
	return `export { definition as ${exportName} } from "${sourcePkg}";\n`;
}

/**
 * @param {string} pkg
 * @param {Array<{icon: string, aliases: string[]}>} icons
 */
function processCustomPackage(pkg, icons) {
	const iconNames = icons.map(({ icon }) => icon);
	const exports = iconNames.join(", ");
	return {
		code: `export { ${exports} } from "${pkg}";\n`,
		count: iconNames.length,
	};
}

/**
 * @param {string} pkg
 * @param {Array<{icon: string, aliases: string[]}>} icons
 * @param {Set<string>} existingExports
 */
function processStandardPackage(pkg, icons, existingExports) {
	let code = "";
	let count = 0;

	for (const { icon, aliases } of icons) {
		// Export main icon if not already exported
		if (!existingExports.has(icon)) {
			code += generateIconExport(pkg, icon, icon);
			existingExports.add(icon);
			count++;
		}

		// Export aliases
		for (const alias of aliases) {
			if (alias === icon || existingExports.has(alias)) {
				continue;
			}
			code += generateIconExport(pkg, icon, alias);
			existingExports.add(alias);
		}
	}

	return { code, count };
}

/**
 * @param {Record<string, {icons: Array<{icon: string, aliases: string[]}>}>} manifest
 */
function generateIconExports(manifest) {
	log("üé®", "Generating icon exports...");

	const existingExports = new Set();
	let iconCode = "";
	let totalIcons = 0;
	const stats = { custom: 0, pro: 0, free: 0, fallback: 0 };

	for (const [pkg, { icons }] of Object.entries(manifest)) {
		const isCustom = pkg.startsWith("@awesome.me/kit-");
		const isPro = pkg.startsWith("@fortawesome/pro-");

		const result = isCustom
			? processCustomPackage(pkg, icons)
			: processStandardPackage(pkg, icons, existingExports);

		iconCode += result.code;
		totalIcons += result.count;

		// Track stats
		if (isCustom) stats.custom += result.count;
		else if (isPro) stats.pro += result.count;
		else stats.free += result.count;
	}

	log("‚úÖ", `Generated ${totalIcons} icon exports`);
	log(
		"üìä",
		`  Free: ${stats.free} | Pro: ${stats.pro} | Custom: ${stats.custom}`,
	);

	return iconCode;
}

/**
 * @param {string} iconExports
 */
function generateJavaScriptFile(iconExports) {
	log("üìù", "Generating src/index.gen.js...");

	const baseCode = dedent`
		import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
		import { createElement } from "react";
		export function Icon(props) { return createElement(FontAwesomeIcon, props)}
	`;

	const content = LEGAL_BANNER + "\n" + baseCode + "\n" + iconExports;
	fs.writeFileSync(join(PATHS.src, "index.gen.js"), content);

	const sizeKB = (Buffer.byteLength(content, "utf8") / 1024).toFixed(2);
	log("‚úÖ", `Generated src/index.gen.js (${sizeKB} KB)`);
}

/**
 * @param {string} iconExports
 */
function generateTypeScriptFile(iconExports) {
	log("üìù", "Generating src/index.gen.ts...");

	const baseCode = dedent`
		import { FontAwesomeIcon, FontAwesomeIconProps } from "@fortawesome/react-fontawesome";
		import { ComponentProps, createElement } from "react";
		export function Icon(props: Omit<ComponentProps<typeof FontAwesomeIcon>, 'icon'> & {icon: IconProp}) { return createElement(FontAwesomeIcon, props as FontAwesomeIconProps)}
		export type IconProp = string | { prefix: string; iconName: string } | [string, string];
	`;

	const content = LEGAL_BANNER + "\n" + baseCode + "\n" + iconExports;
	fs.writeFileSync(join(PATHS.src, "index.gen.ts"), content);

	const sizeKB = (Buffer.byteLength(content, "utf8") / 1024).toFixed(2);
	log("‚úÖ", `Generated src/index.gen.ts (${sizeKB} KB)`);
}

// ============================================================================
// BUNDLING PHASE
// ============================================================================

async function bundleWithEsbuild() {
	log("üì¶", "Bundling with esbuild...");

	const externals = [
		"react",
		"react-dom",
		"@fortawesome/react-fontawesome",
		"@fortawesome/fontawesome-svg-core",
		"@fortawesome/free-solid-svg-icons",
		"@fortawesome/free-brands-svg-icons",
	];

	try {
		const result = await esbuild.build({
			entryPoints: [resolve(PATHS.src, "index.gen.js")],
			outfile: resolve(PATHS.dist, "index.js"),
			external: externals,
			bundle: true,
			platform: "neutral",
			format: "esm",
			treeShaking: true,
			metafile: true,
		});

		// Calculate bundle size
		const bundlePath = resolve(PATHS.dist, "index.js");
		const stats = fs.statSync(bundlePath);
		const sizeKB = (stats.size / 1024).toFixed(2);

		log("‚úÖ", `Generated dist/index.js (${sizeKB} KB)`);

		return result;
	} catch (err) {
		const message = err instanceof Error ? err.message : String(err);
		exitWithError(`Build failed: ${message}`);
	}
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
	console.log("\nüöÄ Rivet Icons Vendor Script\n");

	// Setup phase
	checkEnvironment();
	setupSourceDirectory();
	configureFontAwesomeRegistry();
	installFontAwesomePackages();

	console.log();

	// Generation phase
	const manifest = loadManifest();
	const iconExports = generateIconExports(manifest);
	generateJavaScriptFile(iconExports);
	generateTypeScriptFile(iconExports);

	console.log();

	// Bundle phase
	await bundleWithEsbuild();

	// Success!
	console.log("\nüéâ Done! All files generated and ready to commit:");
	console.log("   - src/index.gen.js");
	console.log("   - src/index.gen.ts");
	console.log("   - dist/index.js");
	console.log("\nüí° Next steps:");
	console.log("   1. Review the generated files");
	console.log("   2. Commit them to git");
	console.log("   3. Consumers can now use the package without any FA token!");
	console.log();
}

// Run the script
main().catch((err) => {
	const message = err instanceof Error ? err.message : String(err);
	error(`Unexpected error: ${message}`);
	if (err instanceof Error && err.stack) {
		console.error(err.stack);
	}
	process.exit(1);
});
