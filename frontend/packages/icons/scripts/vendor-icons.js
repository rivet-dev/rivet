#!/usr/bin/env node
// @ts-nocheck
//
// RIVET ICONS VENDOR SCRIPT
// This script is for Rivet maintainers only.
// It generates icon files from Font Awesome Pro packages.
//
// LEGAL NOTICE: The generated icons are licensed exclusively for use in Rivet
// products and services. Using these icons in any other product or project is
// strictly prohibited and may violate Font Awesome's Terms of Service.
//

import fs from "node:fs";
import { join, resolve } from "node:path";
import dedent from "dedent";
import esbuild from "esbuild";
import {
	PATHS,
	log,
	error,
	exitWithError,
	checkEnvironment,
	setupSourceDirectory,
	configureFontAwesomeRegistry,
	installFontAwesomePackages,
	cleanupGeneratedFiles,
} from "./shared-utils.js";

// ============================================================================
// CONFIGURATION
// ============================================================================

const LEGAL_BANNER = dedent`
	// @ts-nocheck
	// This file is generated by scripts/vendor-icons.js
	// Do not modify this file directly
	// This file includes Font Awesome Pro icons
	//
	// LEGAL NOTICE: This package is licensed exclusively for use in Rivet products
	// and services. Using this package in any other product or project is strictly
	// prohibited and may violate Font Awesome's Terms of Service.


`;

// ============================================================================
// ICON GENERATION PHASE
// ============================================================================

function loadManifest() {
	log("üìã", "Loading icon manifest...");
	try {
		const manifest = JSON.parse(fs.readFileSync(PATHS.manifest, "utf-8"));
		const packageCount = Object.keys(manifest).length;
		const iconCount = Object.values(manifest).reduce(
			(sum, pkg) => sum + pkg.icons.length,
			0,
		);
		log("üìä", `Loaded ${iconCount} icons from ${packageCount} packages`);
		return manifest;
	} catch (err) {
		const message = err instanceof Error ? err.message : String(err);
		exitWithError(`Failed to load manifest: ${message}`);
	}
}

/**
 * @param {string} pkg
 * @param {string} iconName
 */
function checkIconExists(pkg, iconName) {
	const candidate = join(PATHS.srcNodeModules, pkg, `${iconName}.js`);
	return fs.existsSync(candidate);
}

/**
 * @param {string} pkg
 * @param {string} iconName
 * @param {string} exportName
 */
function generateIconExport(pkg, iconName, exportName) {
	const exists = checkIconExists(pkg, iconName);
	const sourcePkg = exists ? `${pkg}/${iconName}` : "@fortawesome/free-solid-svg-icons/faSquare";
	return `export { definition as ${exportName} } from "${sourcePkg}";\n`;
}

/**
 * @param {string} pkg
 * @param {Array<{icon: string, aliases: string[]}>} icons
 */
function processCustomPackage(pkg, icons) {
	const iconNames = icons.map(({ icon }) => icon);
	const exports = iconNames.join(", ");
	return {
		code: `export { ${exports} } from "${pkg}";\n`,
		count: iconNames.length,
	};
}

/**
 * Process legacy custom packages (duotone icons from JS files)
 * These need to be inlined as the legacy format isn't ES module compatible
 * @param {string} pkg
 * @param {Array<{icon: string, aliases: string[]}>} icons
 */
function processLegacyCustomPackage(pkg, icons) {
	// Read the legacy JS file and extract icon definitions
	const jsFilePath = join(PATHS.srcNodeModules, pkg);
	const jsContent = fs.readFileSync(jsFilePath, "utf-8");

	// Extract the icons object from the file
	// The format is: var icons = { "iconName": [width, height, aliases, unicode, pathData], ... }
	const iconsMatch = jsContent.match(/var\s+icons\s*=\s*(\{[\s\S]*?\});/);
	if (!iconsMatch) {
		return { code: "", count: 0 };
	}

	let code = "";
	let count = 0;

	const iconsObj = JSON.parse(iconsMatch[1]);

	for (const { icon } of icons) {
		// Convert faIconName back to icon-name
		const baseName = icon
			.replace(/^fa/, "")
			.replace(/([A-Z])/g, "-$1")
			.toLowerCase()
			.replace(/^-/, "");

		const iconData = iconsObj[baseName];
		if (!iconData) {
			continue;
		}

		// Create an inline icon definition
		// FontAwesome icon format: [width, height, aliases, unicode, pathData]
		const [width, height, , unicode, pathData] = iconData;
		const iconDef = {
			prefix: "fakd",
			iconName: baseName,
			icon: [width, height, [], unicode, pathData],
		};

		code += `export const ${icon} = ${JSON.stringify(iconDef)};\n`;
		count++;
	}

	return { code, count };
}

/**
 * @param {string} pkg
 * @param {Array<{icon: string, aliases: string[]}>} icons
 * @param {Set<string>} existingExports
 */
function processStandardPackage(pkg, icons, existingExports) {
	let code = "";
	let count = 0;

	for (const { icon, aliases } of icons) {
		// Export main icon if not already exported
		if (!existingExports.has(icon)) {
			code += generateIconExport(pkg, icon, icon);
			existingExports.add(icon);
			count++;
		}

		// Export aliases
		for (const alias of aliases) {
			if (alias === icon || existingExports.has(alias)) {
				continue;
			}
			code += generateIconExport(pkg, icon, alias);
			existingExports.add(alias);
		}
	}

	return { code, count };
}

/**
 * @param {Record<string, {icons: Array<{icon: string, aliases: string[]}>}>} manifest
 */
function generateIconExports(manifest) {
	log("üé®", "Generating icon exports...");

	const existingExports = new Set();
	let iconCode = "";
	let totalIcons = 0;
	const stats = { custom: 0, pro: 0, free: 0, fallback: 0 };

	for (const [pkg, { icons }] of Object.entries(manifest)) {
		const isLegacyCustom = pkg.endsWith(".js");
		const isCustom = pkg.startsWith("@awesome.me/kit-") && !isLegacyCustom;
		const isPro = pkg.startsWith("@fortawesome/pro-");

		let result;
		if (isLegacyCustom) {
			result = processLegacyCustomPackage(pkg, icons);
		} else if (isCustom) {
			result = processCustomPackage(pkg, icons);
		} else {
			result = processStandardPackage(pkg, icons, existingExports);
		}

		iconCode += result.code;
		totalIcons += result.count;

		// Track stats
		if (isCustom || isLegacyCustom) stats.custom += result.count;
		else if (isPro) stats.pro += result.count;
		else stats.free += result.count;
	}

	log("‚úÖ", `Generated ${totalIcons} icon exports`);
	log(
		"üìä",
		`  Free: ${stats.free} | Pro: ${stats.pro} | Custom: ${stats.custom}`,
	);

	return iconCode;
}

/**
 * @param {string} iconExports
 */
function generateJavaScriptFile(iconExports) {
	log("üìù", "Generating src/index.gen.js...");

	const baseCode = dedent`
		import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
		import { createElement } from "react";
		export function Icon(props) { return createElement(FontAwesomeIcon, props)}
	`;

	const content = LEGAL_BANNER + "\n" + baseCode + "\n" + iconExports;
	fs.writeFileSync(join(PATHS.src, "index.gen.js"), content);

	const sizeKB = (Buffer.byteLength(content, "utf8") / 1024).toFixed(2);
	log("‚úÖ", `Generated src/index.gen.js (${sizeKB} KB)`);
}

/**
 * @param {string} iconExports
 */
function generateTypeScriptFile(iconExports) {
	log("üìù", "Generating src/index.gen.ts...");

	const baseCode = dedent`
		import { FontAwesomeIcon, FontAwesomeIconProps } from "@fortawesome/react-fontawesome";
		import { ComponentProps, createElement } from "react";
		export function Icon(props: Omit<ComponentProps<typeof FontAwesomeIcon>, 'icon'> & {icon: IconProp}) { return createElement(FontAwesomeIcon, props as FontAwesomeIconProps)}
		export type IconProp = string | { prefix: string; iconName: string } | [string, string];
	`;

	const content = LEGAL_BANNER + "\n" + baseCode + "\n" + iconExports;
	fs.writeFileSync(join(PATHS.src, "index.gen.ts"), content);

	const sizeKB = (Buffer.byteLength(content, "utf8") / 1024).toFixed(2);
	log("‚úÖ", `Generated src/index.gen.ts (${sizeKB} KB)`);
}

// ============================================================================
// BUNDLING PHASE
// ============================================================================

async function bundleWithEsbuild() {
	log("üì¶", "Bundling with esbuild...");

	const externals = [
		"react",
		"react-dom",
		"@fortawesome/react-fontawesome",
		"@fortawesome/fontawesome-svg-core",
	];

	try {
		const result = await esbuild.build({
			entryPoints: [resolve(PATHS.src, "index.gen.js")],
			outfile: resolve(PATHS.dist, "index.js"),
			external: externals,
			bundle: true,
			platform: "neutral",
			format: "esm",
			treeShaking: true,
			metafile: true,
		});

		// Calculate bundle size
		const bundlePath = resolve(PATHS.dist, "index.js");
		const stats = fs.statSync(bundlePath);
		const sizeKB = (stats.size / 1024).toFixed(2);

		log("‚úÖ", `Generated dist/index.js (${sizeKB} KB)`);

		return result;
	} catch (err) {
		const message = err instanceof Error ? err.message : String(err);
		exitWithError(`Build failed: ${message}`);
	}
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
	console.log("\nüöÄ Rivet Icons Vendor Script\n");

	// Check environment before creating any files
	checkEnvironment();

	// Setup and generate with guaranteed cleanup
	setupSourceDirectory();
	try {
		configureFontAwesomeRegistry();
		installFontAwesomePackages();

		console.log();

		// Generation phase
		const manifest = loadManifest();
		const iconExports = generateIconExports(manifest);
		generateJavaScriptFile(iconExports);
		generateTypeScriptFile(iconExports);

		console.log();

		// Bundle phase
		await bundleWithEsbuild();

		// Success!
		console.log("\nüéâ Done! All files generated and ready to commit:");
		console.log("   - src/index.gen.js");
		console.log("   - src/index.gen.ts");
		console.log("   - dist/index.js");
		console.log("\nüí° Next steps:");
		console.log("   1. Review the generated files");
		console.log("   2. Commit them to git");
		console.log("   3. Consumers can now use the package without any FA token!");
		console.log();
	} finally {
		console.log();
		cleanupGeneratedFiles();
	}
}

// Run the script
main().catch((err) => {
	const message = err instanceof Error ? err.message : String(err);
	error(`Unexpected error: ${message}`);
	if (err instanceof Error && err.stack) {
		console.error(err.stack);
	}
	process.exit(1);
});
