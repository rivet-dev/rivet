# Runner Protocol v1

# MARK: Core Primitives

type Id str
type Json str

type GatewayId data[4]
type RequestId data[4]
type MessageIndex u16

# MARK: KV

# Basic types
type KvKey data
type KvValue data
type KvMetadata struct {
	version: data
	# TODO: Rename to update_ts
	createTs: i64
}

# Query types
type KvListAllQuery void
type KvListRangeQuery struct {
	start: KvKey
	end: KvKey
	exclusive: bool
}

type KvListPrefixQuery struct {
	key: KvKey
}

type KvListQuery union {
	KvListAllQuery |
	KvListRangeQuery |
	KvListPrefixQuery
}

# Request types
type KvGetRequest struct {
	keys: list<KvKey>
}

type KvListRequest struct {
	query: KvListQuery
	reverse: optional<bool>
	limit: optional<u64>
}

type KvPutRequest struct {
	keys: list<KvKey>
	values: list<KvValue>
}

type KvDeleteRequest struct {
	keys: list<KvKey>
}

type KvDropRequest void

# Response types
type KvErrorResponse struct {
	message: str
}

type KvGetResponse struct {
	keys: list<KvKey>
	values: list<KvValue>
	metadata: list<KvMetadata>
}

type KvListResponse struct {
	keys: list<KvKey>
	values: list<KvValue>
	metadata: list<KvMetadata>
}

type KvPutResponse void
type KvDeleteResponse void
type KvDropResponse void

# Request/Response unions
type KvRequestData union {
	KvGetRequest |
	KvListRequest |
	KvPutRequest |
	KvDeleteRequest |
	KvDropRequest
}

type KvResponseData union {
	KvErrorResponse |
	KvGetResponse |
	KvListResponse |
	KvPutResponse |
	KvDeleteResponse |
	KvDropResponse
}

# MARK: Actor

# Core
type StopCode enum {
	OK
	ERROR
}

type ActorName struct {
	metadata: Json
}

type ActorConfig struct {
	name: str
	key: optional<str>
	createTs: i64
	input: optional<data>
}

# Intent
type ActorIntentSleep void

type ActorIntentStop void

type ActorIntent union {
	ActorIntentSleep |
	ActorIntentStop
}

# State
type ActorStateRunning void

type ActorStateStopped struct {
	code: StopCode
	message: optional<str>
}

type ActorState union {
	ActorStateRunning |
	ActorStateStopped
}

# MARK: Events
type EventActorIntent struct {
	actorId: Id
	generation: u32
	intent: ActorIntent
}

type EventActorStateUpdate struct {
	actorId: Id
	generation: u32
	state: ActorState
}

type EventActorSetAlarm struct {
	actorId: Id
	generation: u32
	alarmTs: optional<i64>
}

type Event union {
	EventActorIntent |
	EventActorStateUpdate |
	EventActorSetAlarm
}

type EventWrapper struct {
	index: i64
	inner: Event
}

# MARK: Commands

type HibernatingRequest struct {
	gatewayId: GatewayId
	requestId: RequestId
}

type CommandStartActor struct {
	actorId: Id
	generation: u32
	config: ActorConfig
	hibernatingRequests: list<HibernatingRequest>
}

type CommandStopActor struct {
	actorId: Id
	generation: u32
}

type Command union {
	CommandStartActor |
	CommandStopActor
}

type CommandWrapper struct {
	index: i64
	inner: Command
}

# MARK: Tunnel

# Message ID

type MessageIdParts struct {
	# Globally unique ID
	gatewayId: GatewayId
	# Unique ID to the gateway
	requestId: RequestId
	# Unique ID to the request
	messageIndex: MessageIndex
}

type MessageId data[10]

# Ack (deprecated, older protocols that have gc cycles to check for tunnel ack)

type DeprecatedTunnelAck void

# HTTP
type ToClientRequestStart struct {
	actorId: Id
	method: str
	path: str
	headers: map<str><str>
	body: optional<data>
	stream: bool
}

type ToClientRequestChunk struct {
	body: data
	finish: bool
}

type ToClientRequestAbort void

type ToServerResponseStart struct {
	status: u16
	headers: map<str><str>
	body: optional<data>
	stream: bool
}

type ToServerResponseChunk struct {
	body: data
	finish: bool
}

type ToServerResponseAbort void

# WebSocket
type ToClientWebSocketOpen struct {
	actorId: Id
	path: str
	headers: map<str><str>
}

type ToClientWebSocketMessage struct {
	data: data
	binary: bool
}

type ToClientWebSocketClose struct {
	code: optional<u16>
	reason: optional<str>
}

type ToServerWebSocketOpen struct {
	canHibernate: bool
}

type ToServerWebSocketMessage struct {
	data: data
	binary: bool
}

type ToServerWebSocketMessageAck struct {
	index: MessageIndex
}

type ToServerWebSocketClose struct {
	code: optional<u16>
	reason: optional<str>
	hibernate: bool
}

# To Server
type ToServerTunnelMessageKind union {
	DeprecatedTunnelAck |

	# HTTP
	ToServerResponseStart |
	ToServerResponseChunk |
	ToServerResponseAbort |

	# WebSocket
	ToServerWebSocketOpen |
	ToServerWebSocketMessage |
	ToServerWebSocketMessageAck |
	ToServerWebSocketClose
}

type ToServerTunnelMessage struct {
	messageId: MessageId
	messageKind: ToServerTunnelMessageKind
}

# To Client
type ToClientTunnelMessageKind union {
	DeprecatedTunnelAck |

	# HTTP
	ToClientRequestStart |
	ToClientRequestChunk |
	ToClientRequestAbort |

	# WebSocket
	ToClientWebSocketOpen |
	ToClientWebSocketMessage |
	ToClientWebSocketClose
}

type ToClientTunnelMessage struct {
	messageId: MessageId
	messageKind: ToClientTunnelMessageKind
}

# MARK: To Server
type ToServerInit struct {
	name: str
	version: u32
	totalSlots: u32
	lastCommandIdx: optional<i64>
	prepopulateActorNames: optional<map<str><ActorName>>
	metadata: optional<Json>
}

type ToServerEvents list<EventWrapper>

type ToServerAckCommands struct {
	lastCommandIdx: i64
}

type ToServerStopping void

type ToServerPing struct {
	ts: i64
}

type ToServerKvRequest struct {
	actorId: Id
	requestId: u32
	data: KvRequestData
}

type ToServer union {
	ToServerInit |
	ToServerEvents |
	ToServerAckCommands |
	ToServerStopping |
	ToServerPing |
	ToServerKvRequest |
	ToServerTunnelMessage
}

# MARK: To Client
type ProtocolMetadata struct {
	runnerLostThreshold: i64
}

type ToClientInit struct {
	runnerId: Id
	lastEventIdx: i64
	metadata: ProtocolMetadata
}

type ToClientCommands list<CommandWrapper>

type ToClientAckEvents struct {
	lastEventIdx: i64
}

type ToClientKvResponse struct {
	requestId: u32
	data: KvResponseData
}

type ToClientClose void

type ToClient union {
	ToClientInit |
	ToClientClose |
	ToClientCommands |
	ToClientAckEvents |
	ToClientKvResponse |
	ToClientTunnelMessage
}

# MARK: To Runner
type ToRunnerPing struct {
	gatewayId: GatewayId
	requestId: RequestId
	ts: i64
}

# We have to re-declare the entire union since BARE will not generate the
# ser/de for ToClient if it's not a top-level type
type ToRunner union {
	ToRunnerPing |
	ToClientInit |
	ToClientClose |
	ToClientCommands |
	ToClientAckEvents |
	ToClientKvResponse |
	ToClientTunnelMessage
}

# MARK: To Gateway
type ToGatewayPong struct {
	requestId: RequestId
	ts: i64
}

type ToGateway union {
	ToGatewayPong |
	ToServerTunnelMessage
}

# MARK: Serverless
type ToServerlessServerInit struct {
	runnerId: Id
}

type ToServerlessServer union {
	ToServerlessServerInit
}
